---
output: html_document
---

# 생물학적 분석

## 클러스터링 소개

```{r clust-intro0, echo=FALSE}
library(knitr)
opts_chunk$set(cache = TRUE, fig.align = "center", echo=FALSE)
```

데이터를 정규화하고 교란 요인을 제거한 후에는 당면한 생물학적 질문과 관련된 분석을 수행할 수 있습니다. 분석의 정확한 성격은 데이터 세트에 따라 다릅니다. 그럼에도 불구하고 광범위한 맥락에서 유용한 몇 가지 측면이 있으며 다음 몇 장에서 그 중 일부를 논의할 것입니다. scRNA-seq 데이터의 클러스터링부터 시작하겠습니다.

### 소개

scRNA-seq의 가장 유망한 응용 분야 중 하나는 전사 프로필을 기반으로 한 세포 유형의 _de novo_ 발견 및 주석입니다. 계산적으로 이것은 __비지도 클러스터링__에 해당하므로 어려운 문제입니다. 즉, 레이블에 대한 사전 지식 없이 전사체의 유사성을 기반으로 세포 그룹을 식별해야 합니다. 또한 대부분의 경우 _사전에_ 클러스터 수를 알지 못합니다. 높은 수준의 노이즈(기술적 및 생물학적 모두)와 많은 수의 차원(즉, 유전자)으로 인해 문제는 더욱 어려워집니다.

### 차원 축소

대규모 데이터 세트로 작업할 때 일종의 차원 축소 방법을 적용하는 것이 종종 유익할 수 있습니다. 데이터를 저차원 하위 공간에 투영함으로써 종종 노이즈의 양을 크게 줄일 수 있습니다. 추가적인 이점은 일반적으로 2차원 또는 3차원 하위 공간에서 데이터를 시각화하는 것이 훨씬 쉽다는 것입니다. 우리는 이미 PCA(장 \@ref(pca-plot))와 t-SNE(장 \@ref(tsne-map))에 대해 논의했습니다.

### 클러스터링 방법

__비지도 클러스터링__은 다양한 응용 분야에서 유용하며 기계 학습에서 널리 연구되었습니다. 가장 인기 있는 접근 방식 중 일부는 __계층적 클러스터링__, __k-평균 클러스터링__ 및 __그래프 기반 클러스터링__입니다.

#### 계층적 클러스터링

[계층적 클러스터링](https://en.wikipedia.org/wiki/Hierarchical_clustering)에서는 상향식 또는 하향식 접근 방식을 사용할 수 있습니다. 전자의 경우 각 셀은 처음에 자체 클러스터에 할당되고 클러스터 쌍은 이후에 병합되어 계층 구조를 만듭니다.

```{r clust-intro1, fig.align="center", out.width = '80%', fig.cap="원시 데이터"}
knitr::include_graphics("figures/hierarchical_clustering1.png")
```

```{r clust-intro2, fig.align="center", out.width = '80%', fig.cap="계층적 클러스터링 덴드로그램"}
knitr::include_graphics("figures/hierarchical_clustering2.png")
```

하향식 전략을 사용하면 대신 모든 관측치를 하나의 클러스터에 넣고 재귀적으로 각 클러스터를 분할하여 계층 구조를 형성합니다. 이 전략의 장점 중 하나는 방법이 결정적이라는 것입니다.

#### k-평균

[_k_-평균 클러스터링](https://en.wikipedia.org/wiki/K-means_clustering)에서 목표는 _N_개의 객체(셀)를 _k_개의 다른 클러스터로 분할하는 것입니다. 반복적인 방식으로 클러스터 중심이 할당되고 각 셀은 가장 가까운 클러스터에 할당됩니다.

```{r clust-intro3, out.width = '100%', fig.cap="k-평균 클러스터링의 개략도"}
knitr::include_graphics("figures/k-means.png")
```

scRNA-seq 분석을 위한 대부분의 방법에는 어떤 시점에서 _k_-평균 단계가 포함됩니다.

#### 그래프 기반 방법

지난 20년 동안 다양한 영역에서 네트워크를 분석하는 데 많은 관심이 있었습니다. 한 가지 목표는 네트워크에서 노드의 그룹 또는 모듈을 식별하는 것입니다.

```{r clust-intro4, out.width = '100%', fig.cap="그래프 네트워크의 개략도"}
knitr::include_graphics("figures/graph_network.jpg")
```

이러한 방법 중 일부는 각 노드가 셀을 나타내는 그래프를 구축하여 scRNA-seq 데이터에 적용할 수 있습니다. 그래프를 구성하고 에지에 가중치를 할당하는 것은 간단하지 않다는 점에 유의하십시오. 그래프 기반 방법의 한 가지 장점은 일부 방법이 매우 계산적으로 효율적이며 수백만 개의 노드가 포함된 네트워크에 적용할 수 있다는 것입니다.

### 클러스터링의 과제

  * 클러스터 수 _k_는 얼마입니까?
  * 세포 유형이란 무엇입니까?
  * __확장성__: 지난 몇 년 동안 scRNA-seq 실험의 세포 수는 ~$10^2$에서 ~$10^6$까지 여러 자릿수 증가했습니다.
  * 도구가 사용자 친화적이지 않을 수 있습니다.

### scRNA-seq 데이터용 도구

#### [SINCERA](https://research.cchmc.org/pbge/sincera.html)

* SINCERA [@Guo2015-ok]는 계층적 클러스터링을 기반으로 합니다.
* 데이터는 클러스터링 전에 _z_-점수로 변환됩니다.
* 계층 구조에서 첫 번째 단일 클러스터를 찾아 _k_를 식별합니다.

#### [SC3](http://bioconductor.org/packages/SC3/)

```{r clust-intro5, out.width = '100%', fig.cap="SC3 파이프라인"}
knitr::include_graphics("figures/sc3.png")
```

* SC3 [@Kiselev2016-bq]는 PCA 및 스펙트럼 차원 축소를 기반으로 합니다.
* _k_-평균을 활용합니다.
* 추가로 컨센서스 클러스터링을 수행합니다.

#### tSNE + k-평균

* __tSNE__ 맵을 기반으로 합니다.
* _k_-평균을 활용합니다.

#### Seurat 클러스터링

[`Seurat`](https://github.com/satijalab/seurat) 클러스터링은 `SNN-Cliq` 및 이전에 CyTOF 데이터 분석을 위해 제안된 것과 유사한 _커뮤니티 감지_ 접근 방식을 기반으로 합니다[@Levine2015-fk]. `Seurat`가 scRNA-seq 데이터 분석을 위한 올인원 도구와 비슷해졌기 때문에 별도의 장을 할애하여 자세히 논의합니다(아래 참조).

### 클러스터링 비교

두 개의 클러스터링 레이블 세트를 비교하기 위해 [조정된 랜드 지수](https://en.wikipedia.org/wiki/Rand_index)를 사용할 수 있습니다. 이 지수는 두 데이터 클러스터링 간의 유사성을 측정한 것입니다. 조정된 랜드 지수의 값은 $[0;1]$ 간격에 있으며, $1$은 두 클러스터링이 동일하다는 것을 의미하고 $0$은 우연히 예상되는 유사성 수준을 의미합니다.

## 클러스터링 예제 {#clust-methods}

```{r clustering1, echo=TRUE, message=FALSE, warning=FALSE}
library(pcaMethods)
library(SC3)
library(scater)
library(SingleCellExperiment)
library(pheatmap)
library(mclust)
set.seed(1234567)
```

scRNA-seq 데이터의 클러스터링을 설명하기 위해, 우리는 개발 중인 마우스 배아의 세포의 `Deng` 데이터 세트를 고려합니다[@Deng2014-mx]. 우리는 데이터 세트를 전처리하고 사전에 `SingleCellExperiment` 객체를 만들었습니다. 또한 원래 간행물에서 식별된 세포 유형으로 세포에 주석을 달았습니다(`colData` 슬롯의 `cell_type2` 열).

### Deng 데이터 세트

데이터를 로드하고 살펴보겠습니다.

```{r clustering2, echo=TRUE}
deng <- readRDS("data/deng/deng-reads.rds")
```

세포 유형 주석을 살펴보겠습니다.

```{r clustering3, echo=TRUE}
table(colData(deng)$cell_type2)
```

간단한 PCA 분석은 이미 일부 강력한 세포 유형을 분리하고 데이터 구조에 대한 일부 통찰력을 제공합니다.

```{r clustering4, echo=TRUE}
deng <- runPCA(deng)
plotPCA(deng, colour_by = "cell_type2")
```

보시다시피 초기 세포 유형은 매우 잘 분리되지만 세 가지 배반포 시점은 구별하기가 더 어렵습니다.

### SC3

Deng 데이터에 대해 `SC3` 클러스터링을 실행해 보겠습니다. `SC3`의 장점은 `SingleCellExperiment` 객체를 직접 수용할 수 있다는 것입니다.

이제 클러스터 수 _k_(세포 유형)를 모른다고 상상해 보겠습니다. `SC3`는 클러스터 수를 추정할 수 있습니다.

```{r clustering5, echo=TRUE}
deng <- sc3_estimate_k(deng)
metadata(deng)$sc3$k_estimation
```

흥미롭게도 `SC3`에서 예측한 세포 유형 수는 원래 데이터 주석보다 적습니다. 그러나 다른 세포 유형의 초기, 중기 및 후기 단계를 함께 결합하면 정확히 6개의 세포 유형이 됩니다. 병합된 세포 유형을 `colData` 슬롯의 `cell_type1` 열에 저장합니다.

```{r clustering6, echo=TRUE}
plotPCA(deng, colour_by = "cell_type1")
```

이제 `SC3`를 실행할 준비가 되었습니다(클러스터의 생물학적 속성도 계산하도록 요청).

```{r clustering7, echo=TRUE}
deng <- sc3(deng, ks = 10, biology = TRUE, n_cores = 1)
```

`SC3` 결과는 여러 다른 출력으로 구성됩니다(자세한 내용은 [@Kiselev2016-bq] 및 [SC3 비네트](http://bioconductor.org/packages/release/bioc/vignettes/SC3/inst/doc/my-vignette.html) 참조). 여기서는 그 중 일부를 보여줍니다.

컨센서스 행렬:

```{r clustering8, fig.height=6}
sc3_plot_consensus(deng, k = 10, show_pdata = "cell_type2")
```

실루엣 플롯:

```{r clustering9, fig.height=9}
sc3_plot_silhouette(deng, k = 10)
```

발현 행렬의 히트맵:

```{r clustering10, fig.height=6}
sc3_plot_expression(deng, k = 10, show_pdata = "cell_type2")
```

식별된 마커 유전자:

```{r clustering11, fig.height=11}
sc3_plot_markers(deng, k = 10, show_pdata = "cell_type2")
```

`SC3` 클러스터가 강조 표시된 PCA 플롯:

```{r clustering12}
plotPCA(deng, colour_by = "sc3_10_clusters")
```

`SC3` 클러스터링 결과를 원래 간행물 세포 유형 레이블과 비교합니다.

```{r clustering13}
adjustedRandIndex(colData(deng)$cell_type2, colData(deng)$sc3_10_clusters)
```

__참고__ `SC3`는 대화형 `Shiny` 세션에서도 실행할 수 있습니다.

```{r clustering14, eval=FALSE}
### 브라우저를 로드하지만 액세스할 수 없음
sc3_interactive(deng)
```

이 명령은 웹 브라우저에서 `SC3`를 엽니다.

__참고__ 직접 거리 계산으로 인해 세포 수가 5000개 이상이면 `SC3`가 매우 느려집니다. 최대 $10^5$개의 세포를 포함하는 대규모 데이터 세트의 경우 `Seurat`를 사용하는 것이 좋습니다(장 \@ref(clust-intro0) 참조).

* __연습 1__: 8에서 12까지의 $k$에 대해 `SC3`를 실행하고 웹 브라우저에서 다른 클러스터링 솔루션을 탐색합니다.

* __연습 2__: $k$가 8에서 12로 변경될 때 어떤 클러스터가 가장 안정적입니까? ("안정성" 탭 참조)

* __연습 3__: 얻은 클러스터링에 대한 차등 발현 유전자 및 마커 유전자를 확인합니다. $k=10$을 사용하십시오.

* __연습 4__: 마커 유전자 임계값을 변경합니다(기본값은 0.85). __SC3__가 더 많은 마커 유전자를 찾습니까?

### tSNE + kmeans

이전에 본 [tSNE](https://lvdmaaten.github.io/tsne/) 플롯(\@ref(exprs-over8))은 __scater__ 패키지를 사용할 때 [Rtsne](https://cran.r-project.org/web/packages/Rtsne/index.html) 및 [ggplot2](https://cran.r-project.org/web/packages/ggplot2/index.html) 패키지를 사용하여 만들어졌습니다. 여기서도 동일한 작업을 수행합니다.
```{r clustering15, fig.cap = "환자 데이터의 tSNE 맵"}
deng <- runTSNE(deng, rand_seed = 1)
plotTSNE(deng)
```

위 플롯의 모든 점이 검은색이라는 점에 유의하십시오. 이것은 세포가 주석에 따라 색칠되었을 때 이전에 본 것과 다릅니다. 여기에는 주석이 없으며 모든 세포가 동일한 배치에서 나왔으므로 모든 점이 검은색입니다.

이제 tSNE 맵의 점 구름에 _k_-평균 클러스터링 알고리즘을 적용할 것입니다. 구름에서 몇 개의 그룹을 볼 수 있습니까?

$k=8$부터 시작하겠습니다.
```{r clustering16, fig.cap = "k-평균 클러스터링 알고리즘으로 식별된 8개의 색상 클러스터가 있는 환자 데이터의 tSNE 맵"}
colData(deng)$tSNE_kmeans <- as.character(kmeans(reducedDim(deng, "TSNE"), centers = 8)$clust)
plotTSNE(deng, colour_by = "tSNE_kmeans")
```

__연습 7__: $k=10$에 대해 동일한 플롯을 만듭니다.

__연습 8__: `tSNE+kmeans`와 원래 간행물 세포 유형 간의 결과를 비교합니다. `perplexity` 매개변수를 변경하여 결과를 개선할 수 있습니까?

__우리의 해결책__:
```{r clustering17, echo=FALSE}
colData(deng)$tSNE_kmeans <- as.character(kmeans(reducedDim(deng, "TSNE"), centers = 10)$clust)
adjustedRandIndex(colData(deng)$cell_type2, colData(deng)$tSNE_kmeans)
```

눈치채셨겠지만, `tSNE+kmeans`는 확률적이며 실행할 때마다 다른 결과를 제공합니다. 솔루션에 대한 더 나은 개요를 얻으려면 방법을 여러 번 실행해야 합니다. `SC3`도 확률적이지만 컨센서스 단계 덕분에 더 견고하고 다른 결과를 생성할 가능성이 적습니다.

### SINCERA

이전 장에서 언급했듯이 [SINCERA](https://research.cchmc.org/pbge/sincera.html)는 계층적 클러스터링을 기반으로 합니다. 명심해야 할 한 가지 중요한 점은 클러스터링을 수행하기 전에 유전자 수준 z-점수 변환을 수행한다는 것입니다.

```{r clustering18}
# SC3와 동일한 유전자 필터 사용
input <- logcounts(deng[rowData(deng)$sc3_gene_filter, ])
```

```{r clustering19, echo=TRUE, fig.height=7, fig.width=7}
# 유전자별 샘플별 z-점수 변환 수행
dat <- apply(input, 1, function(y) scRNA.seq.funcs::z.transform.helper(y))
# 계층적 클러스터링
dd <- as.dist((1 - cor(t(dat), method = "pearson"))/2)
hc <- hclust(dd, method = "average")
```

클러스터 수를 모르는 경우 [SINCERA](https://research.cchmc.org/pbge/sincera.html)는 지정된 수의 단일 클러스터(1개의 셀만 포함하는 클러스터)를 생성하지 않는 계층적 트리의 최소 높이로 __k__를 식별할 수 있습니다.

```{r clustering20, echo=TRUE}
num.singleton <- 0
kk <- 1
for (i in 2:dim(dat)[2]) {
    clusters <- cutree(hc, k = i)
    clustersizes <- as.data.frame(table(clusters))
    singleton.clusters <- which(clustersizes$Freq < 2)
    if (length(singleton.clusters) <= num.singleton) {
        kk <- i
    } else {
        break;
    }
}
cat(kk)
```

이제 SINCERA 결과를 히트맵으로 시각화해 보겠습니다.

```{r clustering21, fig.cap = "찾은 $k$를 사용하여 SINCERA 방법의 클러스터링 솔루션"}
pheatmap(
    t(dat),
    cluster_cols = hc,
    cutree_cols = kk,
    kmeans_k = 100,
    show_rownames = FALSE
)
```

__연습 10__: `SINCERA`와 원래 간행물 세포 유형 간의 결과를 비교합니다.

__우리의 해결책__:

```{r clustering22, echo=FALSE}
colData(deng)$SINCERA <- as.character(cutree(hc, k = kk))
adjustedRandIndex(colData(deng)$cell_type2, colData(deng)$SINCERA)
```

__연습 11__: __k__를 찾는 데 단일 클러스터 기준을 사용하는 것이 좋은 생각입니까?

### sessionInfo()

<details><summary>세션 정보 보기</summary>
```{r echo=FALSE}
sessionInfo()
```
</details>