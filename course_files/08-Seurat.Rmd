---
output: html_document
---

# Seurat를 사용한 단일 세포 RNA-seq 분석

```{r clust-intro0, echo=FALSE}
library(knitr)
opts_chunk$set(cache = TRUE, fig.align = "center", cache.lazy = FALSE)
```

이 비네트는 Seurat(버전 3) 생태계를 사용하여 몇 가지 일반적인 작업을 소개합니다. Seurat 비네트는 [여기](https://satijalab.org/seurat/articles/get_started.html)에서 사용할 수 있습니다. 그러나 현재 최신 Seurat 버전(버전 4)을 기본으로 합니다. 이전 비네트는 [여기](https://satijalab.org/seurat/articles/archive.html)에서 사용할 수 있습니다.

이제 튜토리얼에 필요한 모든 라이브러리를 로드해 보겠습니다.

```{r warning=FALSE, message=FALSE}
library(Seurat)
library(ggplot2)
library(SingleR)
library(dplyr)
library(celldex)
library(RColorBrewer)
library(SingleCellExperiment)
```

## 기본 품질 관리 및 필터링

두 가지 예비 단계가 완료된 후 분석을 시작합니다. 1) `soupX`를 사용한 주변 RNA 보정, 2) `scrublet`를 사용한 이중체 감지. 두 비네트 모두 이 저장소에서 찾을 수 있습니다.

분석을 시작하려면 `SoupX` 보정 행렬을 읽어 보겠습니다(QC 장 참조). `SoupX` 출력에는 유전자 기호만 있으므로 추가 옵션이 필요하지 않습니다. 일반적인 `Cell Ranger` 출력에서 시작하는 경우 카운트 행렬에 Ensemble ID 또는 유전자 기호를 사용할지 선택할 수 있습니다. 이것은 `gene.column` 옵션을 사용하여 수행됩니다. 기본값은 '2'이며 유전자 기호입니다.

```{r}
adj.matrix <- Read10X("data/update/soupX_pbmc10k_filt")
```

그런 다음 `Seurat` 객체를 만듭니다. Seurat 객체 요약은 1) 세포("샘플") 수가 각 데이터 세트의 설명과 거의 일치하고(10194), 2) 참조에 36601개의 유전자("특징")가 있음을 보여줍니다.

```{r}
srat <- CreateSeuratObject(adj.matrix,project = "pbmc10k") 
srat
```

RAM을 절약하기 위해 메모리에서 `adj.matrix`를 지우고 `Seurat` 객체를 좀 더 자세히 살펴보겠습니다. `str` 명령을 사용하면 클래스의 모든 필드를 볼 수 있습니다.

```{r}
adj.matrix <- NULL
str(srat)
```

Meta.data는 다음 단계에서 가장 중요한 필드입니다. @ 및 [[]] 연산자를 모두 사용하여 액세스할 수 있습니다. 현재 셀당 3개의 필드가 있습니다. 데이터 세트 ID, 셀당 검출된 UMI 리드 수(nCount_RNA) 및 동일한 셀당 발현된(검출된) 유전자 수(nFeature_RNA)입니다.

```{r}
meta <- srat@meta.data
dim(meta)
head(meta)
summary(meta$nCount_RNA)
summary(meta$nFeature_RNA)
```

세포 품질 진단에 유용한 몇 가지 값을 추가해 보겠습니다. 미토콘드리아 유전자는 세포 상태의 유용한 지표입니다. 마우스 데이터 세트의 경우 패턴을 "Mt-"로 변경하거나 _features = ..._ 옵션을 사용하여 유전자 ID를 명시적으로 나열하십시오.

```{r}
srat[["percent.mt"]] <- PercentageFeatureSet(srat, pattern = "^MT-")
```

마찬가지로, 종종 리드의 상당 부분을 차지하는 리보솜 단백질(이름이 __RPS__ 또는 __RPL__로 시작)을 정의할 수 있습니다.

```{r}
srat[["percent.rb"]] <- PercentageFeatureSet(srat, pattern = "^RP[SL]")
```

이제 `scrublet`에서 생성된 이중체 주석을 Seurat 객체 메타데이터에 추가해 보겠습니다.

```{r}
doublets <- read.table("data/update/scrublet_calls.tsv",header = F,row.names = 1)
colnames(doublets) <- c("Doublet_score","Is_doublet")
srat <- AddMetaData(srat,doublets)
head(srat[[]])
```

선택한 메타데이터 특징의 바이올린 플롯을 만들어 보겠습니다. 플롯은 *ID 클래스*라는 범주별로 그룹화됩니다.
ID 클래스는 srat@active.ident 또는 `Idents()` 함수를 사용하여 볼 수 있습니다. 활성 ID는 `SetIdents()`를 사용하여 변경할 수 있습니다.

```{r fig.align="center"}
VlnPlot(srat, features = c("nFeature_RNA","nCount_RNA","percent.mt","percent.rb"),ncol = 4,pt.size = 0.1) & 
  theme(plot.title = element_text(size=10))
```

일부 메타데이터 특징을 서로에 대해 플로팅하고 어떻게 상관되는지 살펴보겠습니다. 각 플롯 위의 숫자는 피어슨 상관 계수입니다.

```{r fig.align="center"}
FeatureScatter(srat, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(srat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
FeatureScatter(srat, feature1 = "nCount_RNA", feature2 = "percent.rb")
FeatureScatter(srat, feature1 = "percent.rb", feature2 = "percent.mt")
FeatureScatter(srat, feature1 = "nFeature_RNA", feature2 = "Doublet_score")
```

위의 플롯은 높은 MT 비율이 낮은 UMI 카운트와 강하게 상관되며 일반적으로 죽은 세포로 해석된다는 것을 분명히 보여줍니다. 그러나 높은 리보솜 단백질 함량은 MT와 강하게 반상관 관계를 보이며 생물학적 신호를 포함하는 것으로 보입니다. 이중체 점수와 발현된 유전자 수 사이에도 강한 상관 관계가 있습니다. 메타데이터에 QC 열을 설정하고 유익한 방식으로 정의해 보겠습니다.

```{r}
srat[['QC']] <- ifelse(srat@meta.data$Is_doublet == 'True','Doublet','Pass')
srat[['QC']] <- ifelse(srat@meta.data$nFeature_RNA < 500 & srat@meta.data$QC == 'Pass','Low_nFeature',srat@meta.data$QC)
srat[['QC']] <- ifelse(srat@meta.data$nFeature_RNA < 500 & srat@meta.data$QC != 'Pass' & srat@meta.data$QC != 'Low_nFeature',paste('Low_nFeature',srat@meta.data$QC,sep = ','),srat@meta.data$QC)
srat[['QC']] <- ifelse(srat@meta.data$percent.mt > 15 & srat@meta.data$QC == 'Pass','High_MT',srat@meta.data$QC)
srat[['QC']] <- ifelse(srat@meta.data$nFeature_RNA < 500 & srat@meta.data$QC != 'Pass' & srat@meta.data$QC != 'High_MT',paste('High_MT',srat@meta.data$QC,sep = ','),srat@meta.data$QC)
table(srat[['QC']])
```

이중체는 검출된 유전자 수가 적은 세포와 종종 겹치지 않는다는 것을 알 수 있습니다. 동시에 후자는 종종 높은 미토콘드리아 함량과 일치합니다. 잠정적인 QC를 통과한 세포에 대해서만 메타데이터를 플로팅해 보겠습니다.

```{r fig.align="center"}
VlnPlot(subset(srat, subset = QC == 'Pass'), 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mt","percent.rb"), ncol = 4, pt.size = 0.1) & 
  theme(plot.title = element_text(size=10))
```

## 정규화 및 차원 축소

추가 분석을 수행하려면 시퀀싱 깊이를 고려하여 데이터를 정규화해야 합니다. 기존 방식은 10,000으로 확장(모든 세포가 전체적으로 10k UMI를 갖는 것처럼)하고 얻은 값을 log2 변환하는 것입니다. 정규화된 데이터는 'RNA' 분석의 `srat[['RNA']]@data`에 저장됩니다.

```{r}
srat <- NormalizeData(srat)
```

다음 단계는 가장 변동이 심한 특징(유전자)을 발견하는 것입니다. 이는 일반적으로 다운스트림 분석에 가장 흥미롭습니다.

```{r}
srat <- FindVariableFeatures(srat, selection.method = "vst", nfeatures = 2000)
```

가장 변동이 심한 상위 10개 유전자를 식별합니다.

```{r}
top10 <- head(VariableFeatures(srat), 10)
top10 
```

레이블이 있거나 없는 변수 특징을 플로팅합니다.

```{r fig.align="center",warning=FALSE}
plot1 <- VariableFeaturePlot(srat)
LabelPoints(plot = plot1, points = top10, repel = TRUE, xnudge = 0, ynudge = 0)
```

`ScaleData`는 정규화된 유전자 발현을 Z-점수(0을 중심으로 하고 분산이 1인 값)로 변환합니다. `srat[['RNA']]@scale.data`에 저장되며 다음 PCA에서 사용됩니다. 기본값은 변수 유전자에 대해서만 스케일링을 실행하는 것입니다.

```{r}
all.genes <- rownames(srat)
srat <- ScaleData(srat, features = all.genes)
```

이제 선형 차원 축소의 일반적인 방법인 PCA를 수행할 수 있습니다. 기본적으로 가장 변동이 심한 2000개의 유전자를 사용합니다.

```{r}
srat <- RunPCA(srat, features = VariableFeatures(object = srat))
```

주성분 "로딩"은 잘 작동하는 데이터 세트에 대한 뚜렷한 모집단의 마커와 일치해야 합니다. & 연산자로 전달하여 ggplot2 기능을 사용하여 많은 플롯 매개변수를 변경할 수 있다는 점에 유의하십시오.

```{r fig.align="center"}
VizDimLoadings(srat, dims = 1:9, reduction = "pca") & 
  theme(axis.text=element_text(size=5), axis.title=element_text(size=8,face="bold"))
```

또는 각 주성분 또는 여러 PC를 한 번에 히트맵으로 만들 수 있습니다.

```{r fig.align="center"}
DimHeatmap(srat, dims = 1:6, nfeatures = 20, cells = 500, balanced = T)
```

DimPlot은 모든 축소된 표현(PCA, tSNE, UMAP 등)을 시각화하는 데 사용됩니다. ID는 여전히 "orig.ident"로 설정되어 있습니다. DimPlot에는 플로팅하려는 차원 축소의 내장 계층이 있습니다. 먼저 UMAP을 찾고, (사용할 수 없는 경우) tSNE, 그 다음 PCA를 찾습니다.

```{r fig.align="center"}
DimPlot(srat, reduction = "pca")
```

정보 손실 없이 사용할 수 있는 PC 수를 찾는 것이 종종 좋습니다. 우리의 경우 10에서 큰 하락이 발생하므로 좋은 _초기_ 선택인 것 같습니다.

```{r fig.align="center"}
ElbowPlot(srat)
```

이제 클러스터링을 할 수 있습니다. 해상도가 높을수록 더 많은 클러스터가 생성됩니다(기본값은 0.8). 셀 유형 마커가 클러스터 정의에 따라 달라지므로 나중에 올바른 클러스터 해상도를 찾는 것이 매우 중요합니다.

```{r}
srat <- FindNeighbors(srat, dims = 1:10)
srat <- FindClusters(srat, resolution = 0.5)
```

시각화를 위해 UMAP 축소 차원 표현도 생성해야 합니다.

```{r}
srat <- RunUMAP(srat, dims = 1:10, verbose = F)
```

클러스터링이 완료되면 활성 ID가 클러스터("메타데이터의 seurat_clusters")로 재설정됩니다. 클러스터 크기를 살펴보겠습니다.

```{r}
table(srat@meta.data$seurat_clusters)
```

DimPlot은 기본적으로 _UMAP_을 사용하며 Seurat 클러스터를 _ID_로 사용합니다.

```{r fig.align="center"}
DimPlot(srat,label.size = 4,repel = T,label = T)
```

클러스터링 해상도 및 기타 가능한 인공물을 제어하기 위해 두 개의 작은 세포 집단을 자세히 살펴보겠습니다. 1) 수지상 세포(DC), 2) 혈소판(혈소판). 이 세포 유형 각각에 대해 두 개의 마커를 시각화해 보겠습니다. DC의 경우 LILRA4 및 TPM2, 혈소판의 경우 PPBP 및 GP1BB입니다.

```{r fig.align="center"}
FeaturePlot(srat, features = c("LILRA4", "TPM2", "PPBP", "GP1BB"))
```

다른 교란 요인을 시각화해 보겠습니다.

```{r fig.align="center"}
FeaturePlot(srat, features = "Doublet_score") & theme(plot.title = element_text(size=10))
FeaturePlot(srat, features = "percent.mt") & theme(plot.title = element_text(size=10))
FeaturePlot(srat, features = "nFeature_RNA") & theme(plot.title = element_text(size=10))
```

QC를 통과하지 못한 세포를 제거하고 플롯을 비교해 보겠습니다. 이제 훨씬 더 정의된 클러스터를 볼 수 있습니다. 필터링된 데이터 세트에는 이제 8824개의 세포가 포함되어 있으므로 약 12%의 세포가 다양한 이유로 제거되었습니다.

```{r fig.align="center"}
DimPlot(srat,label.size = 4,repel = T,label = T)
srat <- subset(srat, subset = QC == 'Pass')
DimPlot(srat,label.size = 4,repel = T,label = T)
``` 

마지막으로, [여기](https://satijalab.org/seurat/archive/v3.1/cell_cycle_vignette.html)에 설명된 대로 세포 주기 점수를 계산해 보겠습니다. 이것은 정규화 및 스케일링 후에 수행해야 합니다. Seurat에는 세포 주기에 관여하는 유전자를 정의하는 내장 목록인 cc.genes(이전) 및 cc.genes.updated.2019(최신)가 있습니다. CellRanger 참조 GRCh38 2.0.0 이상의 경우 cc.genes.updated.2019를 사용하십시오(세 개의 유전자가 이름이 변경되었습니다. MLF1IP, FAM64A 및 HN1이 CENPU, PICALM 및 JPT가 됨). 마우스 세포 주기 유전자의 경우 [여기](https://github.com/satijalab/seurat/issues/2493)에 자세히 설명된 솔루션을 사용할 수 있습니다.

```{r}
cc.genes.updated.2019
s.genes <- cc.genes.updated.2019$s.genes
g2m.genes <- cc.genes.updated.2019$g2m.genes

srat <- CellCycleScoring(srat, s.features = s.genes, g2m.features = g2m.genes)
table(srat[[]]$Phase)
```

기술적 차이로 정의된 클러스터가 있는지 살펴보겠습니다. 미토콘드리아 유전자는 클러스터에 따라 특정 의존성을 보이며 클러스터 2와 12에서 훨씬 낮습니다.

```{r fig.align="center"}
FeaturePlot(srat,features = "percent.mt",label.size = 4,repel = T,label = T) & 
  theme(plot.title = element_text(size=10))
```

```{r fig.align="center"}
VlnPlot(srat,features = "percent.mt") & theme(plot.title = element_text(size=10))
```

리보솜 단백질 유전자는 추정되는 세포 유형에 매우 강한 의존성을 보입니다! 일부 세포 클러스터는 45%만큼, 일부는 15%만큼 적은 것으로 보입니다.

```{r fig.align="center"}
FeaturePlot(srat,features = "percent.rb",label.size = 4,repel = T,label = T) & theme(plot.title = element_text(size=10))
```

```{r fig.align="center"}
VlnPlot(srat,features = "percent.rb") & theme(plot.title = element_text(size=10))
```

세포 유형당 RNA 함량에도 차이가 있습니다. 이전 고려 사항에서 클러스터 6과 7은 QC 필터링된 데이터 세트를 사용하여 클러스터링을 다시 수행할 때 사라질 가능성이 높은 품질이 낮은 세포입니다.

```{r fig.align="center"}
VlnPlot(srat,features = c("nCount_RNA","nFeature_RNA")) & 
  theme(plot.title = element_text(size=10))
```

마지막으로, 세포 주기 점수는 세포 유형에 크게 의존하지 않는 것 같습니다. 그러나 각 그룹에는 극적인 이상치가 있습니다.

```{r fig.align="center"}
FeaturePlot(srat,features = c("S.Score","G2M.Score"),label.size = 4,repel = T,label = T) & 
  theme(plot.title = element_text(size=10))
VlnPlot(srat,features = c("S.Score","G2M.Score")) & 
  theme(plot.title = element_text(size=10))
```

## SCTransform 정규화 및 클러스터링

이중체 및 빈 세포 제거로 광범위한 QC를 수행했으므로 이제 [SCTransform 정규화](https://satijalab.org/seurat/articles/sctransform_vignette.html)를 적용할 수 있습니다. 이는 신호/잡음비를 개선하여 희귀한 세포 집단을 찾는 데 유익한 것으로 나타났습니다. 단일 SCTransform 명령은 `NormalizeData`, `ScaleData` 및 `FindVariableFeatures`를 대체합니다. 또한 `vars.to.regress` 변수를 사용하여 % MT 유전자 및 세포 주기 점수를 보정합니다. 이전 탐색에서 세포 주기 점수나 MT 백분율이 클러스터 간에 크게 변하지 않는 것으로 나타났으므로 생물학적 신호를 제거하지 않고 원치 않는 변동만 제거할 것입니다.

```{r}
srat <- SCTransform(srat, method = "glmGamPoi", ncells = 8824, 
                    vars.to.regress = c("percent.mt","S.Score","G2M.Score"), verbose = F)
srat
```

그런 다음 표준 PCA, UMAP 및 클러스터링을 수행해 보겠습니다. SCT가 이제 활성 분석이라는 점에 유의하십시오. `SCTransform`과 함께 더 많은 PC를 사용하는 것이 일반적입니다. 정확한 수는 데이터 세트에 따라 조정할 수 있습니다.

```{r fig.align="center"}
srat <- RunPCA(srat, verbose = F)
srat <- RunUMAP(srat, dims = 1:30, verbose = F)
srat <- FindNeighbors(srat, dims = 1:30, verbose = F)
srat <- FindClusters(srat, verbose = F)
table(srat[[]]$seurat_clusters)
DimPlot(srat, label = T)
```

클러스터를 올바르게 정의하는 것이 매우 중요합니다. 이전에 언급한 작은 세포 집단, 즉 혈소판과 수지상 세포의 마커를 확인해 보겠습니다. 다른 색상 체계를 시도해 보겠습니다. 어떻게 할 수 있는지 보여주기 위해서입니다.

```{r fig.align="center",warning=F,message=F}
FeaturePlot(srat,"PPBP") & 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
FeaturePlot(srat,"LILRA4") & 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
```

클러스터 6과 14 사이에 혈소판 클러스터가 있으며 아직 식별되지 않았음을 알 수 있습니다. `FindClusters`에서 클러스터링 해상도를 2로 높이면 혈소판 클러스터를 분리하는 데 도움이 되지만(시도해 보세요!) 너무 많은 클러스터가 생성됩니다.

필요한 경우 일부 클러스터를 수동으로 분리할 수 있습니다. 희귀한 세포 집단을 식별하는 데 맞춰진 클러스터링 방법도 있습니다. KNN 그래프에서 더 적은 수의 이웃을 사용하고 Leiden 알고리즘(현재 `scanpy`의 기본값)과 약간 증가된 해상도를 결합해 보겠습니다.

```{r fig.align="center",warning=F,message=F}
srat <- FindNeighbors(srat, dims = 1:30, k.param = 15, verbose = F)
srat <- FindClusters(srat, verbose = F, algorithm = 4, resolution = 0.9)
```

```{r fig.align="center"}
table(srat[[]]$seurat_clusters)
DimPlot(srat, label = T)
```

우리는 이미 클러스터 16이 혈소판에 해당하고 클러스터 15가 수지상 세포에 해당한다는 것을 알고 있습니다. 큰 세포 클러스터가 무엇인지 대략적으로 파악해 보겠습니다.

```{r fig.align="center",warning=F,message=F}
FeaturePlot(srat,"MS4A1") + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("MS4A1: B 세포")
FeaturePlot(srat,"LYZ") + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("LYZ: 단핵구")
FeaturePlot(srat,"NKG7") + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("NKG7: 자연 살해 세포")
FeaturePlot(srat,"CD8B") + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("CD8B: CD8 T 세포")
FeaturePlot(srat,"IL7R") + 
  scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("IL7R: CD4 T 세포")
```

일부 하위 집단의 더 나은 분리를 볼 수 있습니다. 이것들은 아래에서 더 자세히 다룰 것입니다.

## 차등 발현 및 마커 선택

차등 발현을 통해 각 클러스터에 특정한 유전자 마커를 정의할 수 있습니다. 정의상 클러스터가 어떻게 정의되는지에 따라 영향을 받으므로 마커를 정의하기 전에 클러스터링의 올바른 해상도를 찾는 것이 중요합니다. 일부 클러스터에 주목할만한 마커가 없는 경우 클러스터링을 조정하십시오. `RNA` 분석에서 차등 발현을 수행하는 것이 [권장](https://github.com/satijalab/seurat/discussions/4032)되며 `SCTransform`에서는 수행하지 않습니다. 차등 발현은 두 개의 특정 클러스터 간에, 그리고 클러스터와 다른 모든 세포 간에 수행할 수 있습니다.

먼저 활성 분석을 "RNA"로 다시 설정하고 QC에 실패한 세포의 상당 부분을 제거했으므로 정규화 및 스케일링을 다시 수행합니다.

```{r}
DefaultAssay(srat) <- "RNA"
srat <- NormalizeData(srat)
srat <- FindVariableFeatures(srat, selection.method = "vst", nfeatures = 2000)
all.genes <- rownames(srat)
srat <- ScaleData(srat, features = all.genes)
```

다음 함수를 사용하면 양성인 것만 보고하면서 나머지 모든 세포와 비교하여 모든 클러스터에 대한 마커를 찾을 수 있습니다. 매우 빠르고 직관적인 [tf-idf](https://constantamateur.github.io/2020-04-10-scDE/)를 포함하여 마커를 정의하는 데 사용할 수 있는 많은 테스트가 있습니다. 기본적으로 Wilcoxon 순위 합계 검정이 사용됩니다. 시간이 좀 걸립니다. 커피나 차 한 잔을 마실 시간을 가지세요! 속도를 위해 기본 최소 백분율 및 log2FC 컷오프를 높였습니다. 데이터 세트에 맞게 조정해야 합니다!

```{r warning = F,message = F}
all.markers <- FindAllMarkers(srat, only.pos = T, min.pct = 0.5, logfc.threshold = 0.5)
```

마커를 간단히 살펴보겠습니다.

```{r}
dim(all.markers)
table(all.markers$cluster)
top3_markers <- as.data.frame(all.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC))
top3_markers
```

일부 마커는 다른 마커보다 덜 유익합니다. 자세한 분석을 위해 하위 클러스터 간에 차등 발현을 수행하는 것이 좋을 수 있습니다(아래 참조).

## SingleR을 사용한 세포 유형 주석

정의한 마커를 감안할 때 문헌을 검색하고 관찰된 각 세포 유형을 식별할 수 있습니다(PBMC의 경우 가장 쉬울 것입니다). 그러나 SingleR을 사용한 자동 주석을 시도해 볼 수 있습니다. SingleR은 워크플로에 구애받지 않습니다(Seurat, SCE 등과 함께 사용할 수 있음). 고급 사용법이 포함된 자세한 signleR 설명서는 [여기](http://bioconductor.org/books/release/SingleRBook/)에서 확인할 수 있습니다.

celldex 패키지에서 참조 데이터 세트를 가져오겠습니다. `label.main` 및 `label.fine`이라는 두 개의 세포 유형 할당이 있습니다. Monaco Immune Database에 대해서만 주석을 실행할 것이지만, 생성된 자동 주석을 비교하기 위해 다른 두 개를 주석 해제할 수 있습니다.

```{r warning=F,message=F}
monaco.ref <- celldex::MonacoImmuneData()
# hpca.ref <- celldex::HumanPrimaryCellAtlasData()
# dice.ref <- celldex::DatabaseImmuneCellExpressionData()
```

편의를 위해 Seurat 객체를 단일 세포 실험(SCE)으로 변환해 보겠습니다. 그런 다음 `SingleR`을 사용하는 것이 매우 쉬워집니다.

```{r}
sce <- as.SingleCellExperiment(DietSeurat(srat))
sce

monaco.main <- SingleR(test = sce,assay.type.test = 1,ref = monaco.ref,labels = monaco.ref$label.main)
monaco.fine <- SingleR(test = sce,assay.type.test = 1,ref = monaco.ref,labels = monaco.ref$label.fine)
# hpca.main <- SingleR(test = sce,assay.type.test = 1,ref = hpca.ref,labels = hpca.ref$label.main)
# hpca.fine <- SingleR(test = sce,assay.type.test = 1,ref = hpca.ref,labels = hpca.ref$label.fine)
# dice.main <- SingleR(test = sce,assay.type.test = 1,ref = dice.ref,labels = dice.ref$label.main)
# dice.fine <- SingleR(test = sce,assay.type.test = 1,ref = dice.ref,labels = dice.ref$label.fine)
```

일반적인 세포 유형 주석의 요약을 살펴보겠습니다. 이것들은 우리의 기대(그리고 서로)와 상당히 잘 일치합니다.

```{r}
table(monaco.main$pruned.labels)
#table(hpca.main$pruned.labels)
#table(dice.main$pruned.labels)
```

더 세분화된 세포 유형 주석은 안정적으로 얻기가 더 어렵습니다. 이것이 많은 데이터베이스를 비교하고 문헌의 개별 마커를 사용하는 것이 모두 매우 가치 있는 부분입니다.

```{r}
table(monaco.fine$pruned.labels)
# table(hpca.fine$pruned.labels)
# table(dice.fine$pruned.labels)
```

주석을 Seurat 객체 메타데이터에 추가하여 사용할 수 있도록 하겠습니다.

```{r}
srat@meta.data$monaco.main <- monaco.main$pruned.labels
srat@meta.data$monaco.fine <- monaco.fine$pruned.labels

# srat@meta.data$hpca.main   <- hpca.main$pruned.labels
# srat@meta.data$dice.main   <- dice.main$pruned.labels
# srat@meta.data$hpca.fine   <- hpca.fine$pruned.labels
# srat@meta.data$dice.fine   <- dice.fine$pruned.labels
```

마지막으로 세분화된 주석을 시각화해 보겠습니다.

```{r fig.align="center"}
srat <- SetIdent(srat, value = "monaco.fine")
DimPlot(srat, label = T , repel = T, label.size = 3) + NoLegend()
```

세 가지 소스에서 얻은 레이블을 비교하면 많은 흥미로운 불일치를 볼 수 있습니다. 이를 해결하려면 수동 큐레이션이 필요합니다. 그러나 많은 유익한 할당을 볼 수 있습니다. 예를 들어, 작은 클러스터 17은 반복적으로 혈장 B 세포로 식별됩니다. 이 뚜렷한 하위 집단은 CD38 및 CD59와 같은 마커를 표시합니다.

```{r fig.align="center",warning=F,message=F}
FeaturePlot(srat,"CD38") + scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
FeaturePlot(srat,"CD59") + scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
```

마찬가지로 클러스터 13은 MAIT 세포로 식별됩니다. 문헌에 따르면 혈액 MAIT 세포는 CD161(KLRB1) 및 CXCR6과 같은 케모카인의 높은 발현으로 특징지어집니다. 이것은 실제로 사실인 것 같지만 이 세포 유형은 평가하기가 더 어렵습니다.

```{r fig.align="center",warning=F,message=F}
FeaturePlot(srat,"KLRB1") + scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
FeaturePlot(srat,"CXCR6") + scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
```

일반적으로 PBMC의 간단한 예조차도 세포 유형 할당이 얼마나 복잡하고 얼마나 많은 노력이 필요한지 보여줍니다. `singleR`을 사용한 세포 유형 할당/레이블 전송에 대한 자세한 책은 [사용 가능](https://bioconductor.org/books/3.12/SingleRBook/)합니다.

### sessionInfo()

<details><summary>세션 정보 보기</summary>
```{r echo=FALSE}
sessionInfo()
```
</details>