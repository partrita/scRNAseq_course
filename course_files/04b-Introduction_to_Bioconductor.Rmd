---
output: html_document
---

## 깔끔한 데이터

### 깔끔한 데이터란 무엇인가?

깔끔한 데이터는 Hadley Wickham [@wickham_2014]에 의해 주로 정의된 개념입니다. 깔끔한 데이터는 다음과 같은 세 가지 특징을 가집니다.

1. 각 변수는 자체 열을 가집니다.
2. 각 관측치는 자체 행을 가집니다.
3. 각 값은 자체 셀을 가집니다.

다음은 깔끔한 데이터의 예입니다.
```{R Intro-bio0, eval=TRUE, echo=FALSE}
data.frame(Students=c("Mark", "Jane", "Mohammed", "Tom", "Celia"), Subject=c("Maths", "Biology", "Physics", "Maths", "Computing"), Years=c(1,2,3,2,3), Score=c(5,6,4,7,9))
```

다음은 깔끔하지 않은 데이터의 예입니다.
```{R Intro-bio1, eval=TRUE, echo=FALSE}
data.frame(Students=c("Matt", "Matt", "Ellie", "Ellie", "Tim", "Tim", "Louise", "Louise", "Kelly", "Kelly"), Sport=c("Tennis","Tennis", "Rugby", "Rugby","Football", "Football","Swimming","Swimming", "Running", "Running"), Category=c("Wins", "Losses", "Wins", "Losses", "Wins", "Losses", "Wins", "Losses", "Wins", "Losses"), Counts=c(0,1,3,2,1,4,2,2,5,1))
```

과제 1: 깔끔하지 않은 데이터는 어떤 면에서 깔끔하지 않습니까? 깔끔하지 않은 데이터를 어떻게 깔끔하게 만들 수 있습니까?

깔끔한 데이터는 일반적으로 깔끔하지 않은 데이터보다 작업하기가 더 쉽습니다. 특히 ggplot과 같은 패키지로 작업하는 경우 더욱 그렇습니다. 다행히도 깔끔하지 않은 데이터를 깔끔하게 만드는 데 사용할 수 있는 패키지가 있습니다. 오늘 우리는 깔끔하지 않은 데이터를 깔끔하게 만드는 데 사용할 수 있는 tidyr 패키지에서 사용할 수 있는 몇 가지 함수를 살펴보겠습니다. 데이터 정리에 대해 더 자세히 알고 싶다면 Garrett Grolemund와 Hadley Wickham의 "R for Data Science"를 읽는 것이 좋습니다. 전자 사본은 여기에서 볼 수 있습니다: http://r4ds.had.co.nz/

위의 깔끔하지 않은 데이터는 두 변수(`Wins` 및 `Losses`)가 한 열(`Category`)에 저장되어 있기 때문에 깔끔하지 않습니다. 이것은 데이터가 깔끔하지 않을 수 있는 일반적인 방법입니다. 이 데이터를 정리하려면 `Wins`와 `Losses`를 열로 만들고 `Counts`의 값을 이러한 열에 저장해야 합니다. 다행히도 tidyverse 패키지에는 이 작업을 수행하는 함수가 있습니다. 이 함수는 `spread`라고 하며 `key`와 `value`라는 두 가지 인수를 사용합니다. 여러 변수를 포함하는 열의 이름을 `key`에 전달하고 여러 변수의 값을 포함하는 열의 이름을 `value`에 전달해야 합니다. 예를 들어:

```{R Intro-bio2, echo=TRUE, eval=TRUE, message=FALSE}
library(tidyverse)
sports<-data.frame(Students=c("Matt", "Matt", "Ellie", "Ellie", "Tim", "Tim", "Louise", "Louise", "Kelly", "Kelly"), Sport=c("Tennis","Tennis", "Rugby", "Rugby","Football", "Football","Swimming","Swimming", "Running", "Running"), Category=c("Wins", "Losses", "Wins", "Losses", "Wins", "Losses", "Wins", "Losses", "Wins", "Losses"), Counts=c(0,1,3,2,1,4,2,2,5,1))
sports

spread(sports, key=Category, value=Counts)
```

과제 2: 아래에 정의된 데이터 프레임 `foods`는 깔끔하지 않습니다. 이유를 알아내고 `spread()`를 사용하여 정리하십시오.

```{R Intro-bio3, echo=TRUE, eval=TRUE}
foods<-data.frame(student=c("Antoinette","Antoinette","Taylor", "Taylor", "Alexa", "Alexa"), Category=c("Dinner", "Dessert", "Dinner", "Dessert", "Dinner","Dessert"), Frequency=c(3,1,4,5,2,1))
```

데이터가 깔끔하지 않을 수 있는 또 다른 일반적인 방법은 열이 변수가 아닌 값인 경우입니다. 예를 들어 아래 데이터 프레임은 일부 학생들이 5월과 6월에 치른 시험에서 받은 백분율을 보여줍니다. `May` 및 `June` 열이 변수가 아닌 값이므로 데이터가 깔끔하지 않습니다.

```{R Intro-bio4}
percentages<-data.frame(student=c("Alejandro", "Pietro", "Jane"), "May"=c(90,12,45), "June"=c(80,30,100))
```

다행히도 tidyverse 패키지에는 이 문제를 처리하는 함수도 있습니다. `gather()`는 값인 열의 이름, `key` 및 `value`를 인수로 사용합니다. 이번에는 `key`가 열 이름으로 값이 있는 변수의 이름이고 `value`는 여러 열에 값이 분산된 변수의 이름입니다. 즉:

```{R Intro-bio5}
gather(percentages, "May", "June", key="Month", value = "Percentage")
```

이러한 예는 단일 세포 RNA-seq 분석과 관련이 없지만 깔끔한 데이터와 깔끔하지 않은 데이터의 특징을 설명하는 데 도움이 되도록 설계되었습니다. 데이터가 깔끔한 형식으로 저장되어 있으면 단일 세포 RNA-seq 데이터를 훨씬 쉽게 분석할 수 있습니다. 다행히도 단일 세포 RNA-seq 분석을 용이하게 하기 위해 일반적으로 사용하는 데이터 구조는 일반적으로 데이터를 깔끔한 방식으로 저장하도록 권장합니다.

### 풍부한 데이터란 무엇인가?

'풍부한 데이터'를 구글링하면 이 용어에 대한 다양한 정의를 찾을 수 있습니다. 이 과정에서는 '풍부한 데이터'를 여러 소스의 정보를 결합하여 생성된 데이터를 의미하는 데 사용할 것입니다. 예를 들어, 단일 세포 RNA-seq 실험에서 세포 전체의 유전자 발현 값 행렬뿐만 아니라 실험이 수행된 방법에 대한 정보도 포함하는 R 객체를 만들어 풍부한 데이터를 만들 수 있습니다. 아래에서 논의할 `SingleCellExperiment` 클래스의 객체는 풍부한 데이터의 예입니다.

```{r Intro-bio6, echo=FALSE, message=FALSE}
library(knitr)
library(scater)
opts_chunk$set(cache = TRUE, fig.align = "center")
set.seed(1)
```

### `SingleCellExperiment` 클래스

[`SingleCellExperiment`](http://bioconductor.org/packages/SingleCellExperiment)(SCE)는 단일 세포 실험의 데이터를 저장하기 위한 S4 클래스입니다. 여기에는 스파이크인 정보, 차원 축소 좌표 및 각 세포의 크기 인자뿐만 아니라 유전자 및 라이브러리에 대한 일반적인 메타데이터를 저장하고 검색하는 특수 메서드가 포함됩니다.

실제로 이 클래스의 객체는 생성자를 사용하여 만들 수 있습니다.
```{r Intro-bio7, message=FALSE, warning=FALSE}
library(SingleCellExperiment)
counts <- matrix(rpois(100, lambda = 10), ncol=10, nrow=10)
rownames(counts) <- paste("gene", 1:10, sep = "")
colnames(counts) <- paste("cell", 1:10, sep = "")
sce <- SingleCellExperiment(
    assays = list(counts = counts),
    rowData = data.frame(gene_names = paste("gene_name", 1:10, sep = "")),
    colData = data.frame(cell_names = paste("cell_name", 1:10, sep = ""))
)
sce
```

`SingleCellExperiment`에서 사용자는 분석 항목에 임의의 이름을 할당할 수 있습니다. 패키지 간의 상호 운용성을 지원하기 위해 저자는 특정 데이터 유형에 대한 이름이 무엇이어야 하는지에 대한 몇 가지 제안을 제공합니다.

* __counts__: 원시 카운트 데이터, 예: 특정 유전자에 대한 읽기 또는 전사체 수.
* __normcounts__: 원래 카운트와 동일한 척도의 정규화된 값. 예를 들어, 1을 중심으로 하는 세포 특이적 크기 인자로 나눈 카운트.
* __logcounts__: 로그 변환된 카운트 또는 카운트와 유사한 값. 대부분의 경우 이는 로그 변환된 정규화된 카운트로 정의됩니다. 예: 로그 밑 2와 의사 카운트 1 사용.
* __cpm__: 백만 분의 카운트. 이는 각 세포의 각 유전자에 대한 읽기 카운트를 백만 단위의 각 세포 라이브러리 크기로 나눈 값입니다.
* __tpm__: 백만 분의 전사체. 이는 각 세포의 각 유전자에 대한 전사체 수를 해당 세포의 총 전사체 수(백만 단위)로 나눈 값입니다.

이러한 제안된 이름 각각에는 `SingleCellExperiment`를 편리하게 조작하기 위한 적절한 getter/setter 메서드가 있습니다. 예를 들어, (매우 구체적으로 명명된) `counts` 슬롯을 가져와 정규화하고 `normcounts`에 할당할 수 있습니다.

```{r Intro-bio8}
normcounts(sce) <- log2(counts(sce) + 1)
sce
dim(normcounts(sce))
head(normcounts(sce))
```

### `scater` 패키지

[`scater`](http://bioconductor.org/packages/scater/)는 단일 세포 RNA-seq 분석을 위한 R 패키지입니다[@McCarthy2017-kb]. 이 패키지에는 추가적인 다운스트림 분석 전에 데이터의 품질 관리, 시각화 및 전처리를 위한 몇 가지 유용한 메서드가 포함되어 있습니다.

`scater`는 다음과 같은 기능을 제공합니다.

* QC 메트릭의 자동 계산
* 의사 정렬을 사용한 읽기 데이터에서 전사체 정량화
* 데이터 형식 표준화
* 탐색적 분석을 위한 풍부한 시각화
* Bioconductor 세계로의 원활한 통합
* 간단한 정규화 방법

모든 단일 세포 RNA-seq 분석에 `scater`를 사용하는 것을 강력히 권장하며, `scater`는 이 과정의 첫 번째 부분의 기초입니다.

아래 그림에서 볼 수 있듯이 `scater`는 매핑 및 정렬 후 발현 행렬의 품질 관리, 필터링 및 정규화에 도움이 됩니다. <span style="color:red">이 그림은 `SCESet` 클래스가 사용된 `scater`의 원래 버전을 나타냅니다. 최신 버전에서는 `SCESet`을 `SingleCellExperiment` 클래스로 대체할 수 있다는 점을 제외하고 이 그림은 여전히 정확합니다.</span>


![](figures/scater_qc_workflow.png)