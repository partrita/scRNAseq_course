---
output: html_document
---

## 차등 발현(DE) 분석

```{r de-intro0, echo=FALSE}
library(knitr)
opts_chunk$set(cache = TRUE, fig.align = "center")
```

### 대량 RNA-seq

대량 RNA-seq 데이터로 작업할 때 가장 일반적인 분석 유형 중 하나는 차등적으로 발현되는 유전자를 식별하는 것입니다. 두 조건(예: 돌연변이 및 야생형 또는 자극 및 비자극) 간에 변화하는 유전자를 비교함으로써 변화의 기본이 되는 분자 메커니즘을 특성화할 수 있습니다.

여러 가지 다른 방법(예: [DESeq2](https://bioconductor.org/packages/DESeq2) 및 [edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html))이 대량 RNA-seq를 위해 개발되었습니다. 또한 RNA-seq 데이터가 RT-qPCR을 사용하여 검증된 광범위한 [데이터 세트](http://genomebiology.biomedcentral.com/articles/10.1186/gb-2013-14-9-r95)도 있습니다. 이 데이터는 DE 찾기 알고리즘을 벤치마킹하는 데 사용할 수 있으며 사용 가능한 증거는 알고리즘이 매우 잘 수행되고 있음을 시사합니다.

### 단일 세포 RNA-seq

대량 RNA-seq와 달리 scRNA-seq에서는 일반적으로 정의된 실험 조건 집합이 없습니다. 대신 이전 장(\@ref(clust-methods))에서 보여준 것처럼 비지도 클러스터링 접근 방식을 사용하여 세포 그룹을 식별할 수 있습니다. 그룹이 식별되면 그룹 간의 분산 차이를 비교하거나(SC3에서 구현된 Kruskal-Wallis 테스트와 같이) 클러스터 간의 유전자 발현을 쌍으로 비교하여 차등적으로 발현되는 유전자를 찾을 수 있습니다. 다음 장에서는 주로 쌍별 비교를 위해 개발된 도구를 고려할 것입니다.

### 분포의 차이

대량 RNA-seq와 달리 단일 세포 실험에서는 비교하는 각 그룹에 대해 일반적으로 많은 수의 샘플(즉, 세포)이 있습니다. 따라서 대량 RNASeq의 표준인 평균 발현 추정치만 비교하는 대신 각 그룹의 전체 발현 값 분포를 활용하여 그룹 간의 차이를 식별할 수 있습니다.

분포를 비교하는 두 가지 주요 접근 방식이 있습니다. 첫째, 기존 통계 모델/분포를 사용하고 각 그룹의 발현에 동일한 유형의 모델을 피팅한 다음 각 모델의 매개변수 차이를 테스트하거나 특정 매개변수가 그룹에 따라 다를 수 있는 경우 모델이 더 잘 맞는지 테스트할 수 있습니다. 예를 들어, 장 \@ref(dealing-with-confounders)에서는 `edgeR`을 사용하여 다른 배치에서 평균 발현이 다를 수 있도록 허용하는 것이 데이터의 음의 이항 모델의 적합도를 크게 향상시키는지 테스트했습니다.

또는 발현 값이 특정 분포를 따른다고 가정하지 않는 비모수적 테스트(예: [Kolmogorov-Smirnov 테스트(KS-테스트)](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test))를 사용할 수 있습니다. 비모수적 테스트는 일반적으로 관찰된 발현 값을 순위로 변환하고 한 그룹의 순위 분포가 다른 그룹의 순위 분포와 크게 다른지 테스트합니다. 그러나 일부 비모수적 방법은 단일 세포 RNA-seq 발현 데이터의 드롭아웃(0)과 같이 많은 수의 동점 값이 있는 경우 실패합니다. 또한 모수적 테스트의 조건이 충족되면 일반적으로 비모수적 테스트보다 더 강력합니다.

### 단일 세포 RNA-seq 데이터 모델

scRNA-seq 데이터의 가장 일반적인 모델은 음의 이항 모델입니다.

```{r de-intro1, fig.cap="1000개 세포에 대한 단일 유전자의 리드 카운트의 음의 이항 분포"}
set.seed(1)
hist(
    rnbinom(
        1000, 
        mu = 10, 
        size = 100), 
    col = "grey50", 
    xlab = "리드 카운트",
    main = "음의 이항"
)
```
평균:
$\mu = mu$

분산:
$\sigma^2 = mu + mu^2/size$

평균 발현(mu)과 분산에 반비례하는 분산(size)으로 매개변수화됩니다. 음의 이항 모델은 대량 RNA-seq 데이터에 매우 잘 맞으며 이러한 데이터를 위해 설계된 대부분의 통계적 방법에 사용됩니다. 또한 고유 분자 식별자(UMI)로 태그가 지정된 데이터에서 얻은 분자 카운트 분포에 매우 잘 맞는 것으로 나타났습니다([Grun et al. 2014](http://www.nature.com/nmeth/journal/v11/n6/full/nmeth.2930.html), [Islam et al. 2011](http://genome.cshlp.org/content/21/7/1160)).

그러나 원시 음의 이항 모델은 0이 아닌 리드 카운트에 비해 높은 드롭아웃 비율로 인해 전체 길이 전사체 데이터에 잘 맞지 않습니다. 이러한 유형의 데이터에 대해 다양한 0-과잉 음의 이항 모델이 제안되었습니다(예: [MAST](https://bioconductor.org/packages/release/bioc/html/MAST.html), [SCDE](https://bioconductor.org/packages/release/bioc/html/scde.html)).

```{r de-intro2, fig.cap="0-과잉 음의 이항 분포"}
d <- 0.5;
counts <- rnbinom(
    1000, 
    mu = 10, 
    size = 100
)
counts[runif(1000) < d] <- 0
hist(
    counts, 
    col = "grey50", 
    xlab = "리드 카운트",
    main = "0-과잉 NB"
)
```
평균:
$\mu = mu \cdot (1 - d)$

분산:
$\sigma^2 = \mu \cdot (1-d) \cdot (1 + d \cdot \mu + \mu / size)$

이러한 모델은 드롭아웃 비율에 대한 새로운 매개변수 $d$를 음의 이항 모델에 도입합니다. 19장에서 보았듯이 유전자의 드롭아웃 비율은 유전자의 평균 발현과 강하게 상관됩니다. 다른 0-과잉 음의 이항 모델은 mu와 d 간의 다른 관계를 사용하며 일부는 각 유전자의 발현에 대해 $\mu$와 $d$를 독립적으로 피팅할 수 있습니다.

마지막으로, 여러 방법은 전사적 버스팅의 기계론적 모델을 기반으로 하는 포아송-베타 분포를 사용합니다. 이 모델에 대한 강력한 실험적 지원이 있으며([Kim and Marioni, 2013](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2013-14-1-r7)) scRNA-seq 데이터에 잘 맞지만 음의 이항 모델보다 사용하기가 덜 쉽고 음의 이항 모델보다 구축할 기존 방법이 훨씬 적습니다.

```{r de-intro3, pois-beta-plot, fit.cap="포아송-베타 분포"}
a <- 0.1
b <- 0.1
g <- 100
lambdas <- rbeta(1000, a, b)
counts <- sapply(g*lambdas, function(l) {rpois(1, lambda = l)})
hist(
    counts, 
    col = "grey50", 
    xlab = "리드 카운트",
    main = "포아송-베타"
)
```
평균:
$\mu = g \cdot a / (a + b)$

분산:
$\sigma^2 = g^2 \cdot a \cdot b/((a + b + 1) \cdot (a + b)^2)$

이 모델은 전사 활성화율 $a$, 전사 억제율 $b$, 유전자좌에서 전사가 활성 상태일 때의 전사체 생산율 $g$라는 세 가지 매개변수를 사용합니다. 차등 발현 방법은 각 매개변수를 그룹 간의 차이에 대해 테스트하거나 하나만(종종 $g$) 테스트할 수 있습니다.

이러한 모든 모델은 특정 DE 알고리즘에 따라 배치 효과 또는 라이브러리 깊이와 같은 다른 유전자 발현 차이의 원인을 명시적으로 설명하기 위해 추가로 확장될 수 있습니다.

__연습__: 각 분포의 매개변수를 변경하여 유전자 발현 분포에 미치는 영향을 탐색합니다. 포아송-베타 모델과 음의 이항 모델은 얼마나 유사합니까?

## 실제 데이터 세트의 DE

```{r de-real1, echo=TRUE, message=FALSE, warning=FALSE}
library(scRNA.seq.funcs)
library(edgeR)
#library(monocle)
library(MAST)
library(ROCR)
set.seed(1)
```

### 소개

다른 단일 세포 차등 발현 방법을 테스트하기 위해 7-17장의 Blischak 데이터 세트를 사용할 것입니다.
이 실험에서는 단일 세포 데이터 외에 각 세포주에 대한 대량 RNA-seq 데이터가 생성되었습니다. 우리는 각 단일 세포 방법의 정확성을 평가하기 위한 근거로 각 대량 데이터에 대한 표준 방법을 사용하여 식별된 차등적으로 발현되는 유전자를 사용할 것입니다. 시간을 절약하기 위해 이것을 미리 계산했습니다. 아래 명령을 실행하여 이 데이터를 로드할 수 있습니다.

```{r de-real2}
DE <- read.table("data/tung/TPs.txt")
notDE <- read.table("data/tung/TNs.txt")
GroundTruth <- list(
    DE = as.character(unlist(DE)), 
    notDE = as.character(unlist(notDE))
)
```

이 근거는 개인 NA19101과 NA19239의 비교를 위해 생성되었습니다. 이제 각 단일 세포 데이터를 로드합니다.

```{r de-real3}
molecules <- read.table("data/tung/molecules.txt", sep = "\t")
anno <- read.table("data/tung/annotation.txt", sep = "\t", header = TRUE)
keep <- anno[,1] == "NA19101" | anno[,1] == "NA19239"
data <- molecules[,keep]
group <- anno[keep,1]
batch <- anno[keep,4]
# 최소 6개 세포에서 발현되지 않는 유전자 제거
gkeep <- rowSums(data > 0) > 5;
counts <- data[gkeep,]
# 라이브러리 크기 정규화
lib_size = colSums(counts)
norm <- t(t(counts)/lib_size * median(lib_size)) 
# 라이브러리 크기가 백만 분자 미만인 데이터 세트에 대한 CPM 변형
```

이제 다양한 단일 세포 DE 방법을 비교할 것입니다. R 패키지로 사용할 수 있고 비교적 빠르게 실행되는 방법만 실행할 것입니다.

### 콜모고로프-스미르노프 검정

작업하기 가장 쉬운 유형의 테스트는 비모수적 테스트입니다. 가장 일반적으로 사용되는 비모수적 테스트는 [콜모고로프-스미르노프 검정](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test)(KS-검정)이며, 두 개인의 각 유전자에 대한 분포를 비교하는 데 사용할 수 있습니다. KS-검정은 두 모집단 각각의 각 유전자 발현의 경험적 누적 분포 간의 거리를 정량화합니다. 평균 발현의 변화와 변동성의 변화에 민감합니다. 그러나 데이터가 연속적이라고 가정하며 데이터에 많은 수의 동일한 값(예: 0)이 포함된 경우 성능이 저하될 수 있습니다. KS-검정의 또 다른 문제는 큰 표본 크기에 대해 매우 민감할 수 있으므로 차이의 크기가 매우 작더라도 유의하게 나올 수 있다는 것입니다.

```{r de-real4, echo=FALSE, out.width = '60%', fig.cap="두 표본 콜모고로프-스미르노프 통계량의 그림. 빨간색과 파란색 선은 각각 경험적 분포 함수에 해당하며 검은색 화살표는 두 표본 KS 통계량입니다. ([여기](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test)에서 가져옴)"}
knitr::include_graphics("figures/KS2_Example.png")
```

이제 테스트를 실행합니다.

```{r de-real5, message=FALSE, warning=FALSE}
pVals <- apply(
    norm, 1, function(x) {
        ks.test(
            x[group == "NA19101"], 
            x[group == "NA19239"]
        )$p.value
    }
)
# 다중 검정 보정
pVals <- p.adjust(pVals, method = "fdr")
```

이 코드는 발현 행렬, 데이터의 각 행(1로 지정)에 함수를 "적용"합니다. 함수에서는 ks.test 출력에서 p.value만 반환합니다. 이제 KS-검정으로 근거 양성 및 음성 DE 유전자가 얼마나 많이 검출되었는지 고려할 수 있습니다.

#### 정확도 평가

```{r de-real6}
sigDE <- names(pVals)[pVals < 0.05]
length(sigDE) 
# KS-DE 유전자 수
sum(GroundTruth$DE %in% sigDE) 
# 실제 DE 유전자인 KS-DE 유전자 수
sum(GroundTruth$notDE %in% sigDE)
# 실제로는 DE가 아닌 KS-DE 유전자 수
```

보시다시피 KS-검정(위양성)에 의해 DE로 식별된 근거 음성 유전자가 근거 양성 유전자(진양성)보다 훨씬 많지만, 이는 notDE 유전자의 수가 더 많기 때문일 수 있으므로 일반적으로 이러한 카운트를 진양성률(TPR), TP/(TP + FN) 및 위양성률(FPR), FP/(FP+TP)로 정규화합니다.

```{r de-real7}
tp <- sum(GroundTruth$DE %in% sigDE)
fp <- sum(GroundTruth$notDE %in% sigDE)
tn <- sum(GroundTruth$notDE %in% names(pVals)[pVals >= 0.05])
fn <- sum(GroundTruth$DE %in% names(pVals)[pVals >= 0.05])
tpr <- tp/(tp + fn)
fpr <- fp/(fp + tn)
cat(c(tpr, fpr))
```
이제 TPR이 FPR보다 훨씬 높다는 것을 알 수 있으며, 이는 KS 검정이 DE 유전자를 식별하고 있음을 나타냅니다.

지금까지 단일 유의성 임계값에서만 성능을 평가했습니다. 종종 임계값을 변경하고 다양한 값에 대한 성능을 평가하는 것이 유익합니다. 그런 다음 이것은 수신기-작동 특성 곡선(ROC)으로 플로팅되고 일반적인 정확도 통계는 이 곡선 아래의 면적(AUC)으로 계산할 수 있습니다. 이 플로팅을 용이하게 하기 위해 ROCR 패키지를 사용할 것입니다.

```{r de-real8, fig.cap="KS-검정에 대한 ROC 곡선."}
# 우리가 근거를 아는 유전자만 고려
pVals <- pVals[names(pVals) %in% GroundTruth$DE | 
               names(pVals) %in% GroundTruth$notDE] 
truth <- rep(1, times = length(pVals));
truth[names(pVals) %in% GroundTruth$DE] = 0;
pred <- ROCR::prediction(pVals, truth)
perf <- ROCR::performance(pred, "tpr", "fpr")
ROCR::plot(perf)
aucObj <- ROCR::performance(pred, "auc")
aucObj@y.values[[1]] # AUC
```

마지막으로 다른 DE 방법의 비교를 용이하게 하기 위해 이 코드를 함수에 넣어 반복할 필요가 없도록 하겠습니다.

```{r de-real9}
DE_Quality_AUC <- function(pVals) {
    pVals <- pVals[names(pVals) %in% GroundTruth$DE | 
                   names(pVals) %in% GroundTruth$notDE]
    truth <- rep(1, times = length(pVals));
    truth[names(pVals) %in% GroundTruth$DE] = 0;
    pred <- ROCR::prediction(pVals, truth)
    perf <- ROCR::performance(pred, "tpr", "fpr")
    ROCR::plot(perf)
    aucObj <- ROCR::performance(pred, "auc")
    return(aucObj@y.values[[1]])
}
```

### 윌콕슨/만-휘트니-U 검정

윌콕슨 순위 합 검정은 또 다른 비모수적 검정이지만, 한 그룹의 값이 다른 그룹의 값보다 큰지/작은지를 구체적으로 검정합니다. 따라서 종종 두 그룹 간의 평균 발현 차이에 대한 검정으로 간주됩니다. 반면 KS-검정은 발현 값의 분포에 대한 모든 변화에 민감합니다.

```{r de-real10, fig.cap="윌콕슨 검정에 대한 ROC 곡선.", message=FALSE, warning=FALSE}
pVals <- apply(
    norm, 1, function(x) {
        wilcox.test(
            x[group == "NA19101"], 
            x[group == "NA19239"]
        )$p.value
    }
)
# 다중 검정 보정
pVals <- p.adjust(pVals, method = "fdr")
DE_Quality_AUC(pVals)
```

### edgeR

우리는 이미 \@ref(dealing-with-confounders) 장에서 차등 발현에 edgeR을 사용했습니다. edgeR은 유전자 발현의 음의 이항 모델을 기반으로 하며 일반화 선형 모델(GLM) 프레임워크를 사용하여 배치와 같은 다른 요인을 모델에 포함할 수 있습니다.

```{r de-real11, fig.cap="edgeR에 대한 ROC 곡선.", message=FALSE}
dge <- DGEList(
    counts = counts, 
    norm.factors = rep(1, length(counts[1,])), 
    group = group
)
group_edgeR <- factor(group)
design <- model.matrix(~ group_edgeR)
dge <- estimateDisp(dge, design = design, trend.method = "none")
fit <- glmFit(dge, design)
res <- glmLRT(fit)
pVals <- res$table[,4]
names(pVals) <- rownames(res$table)

pVals <- p.adjust(pVals, method = "fdr")
DE_Quality_AUC(pVals)
```

<!-- 
### Monocle

[Monocle](https://bioconductor.org/packages/release/bioc/html/monocle.html)은 DE에 대해 여러 다른 모델을 사용할 수 있습니다. 카운트 데이터의 경우 음의 이항 모델(negbinomial.size)을 권장합니다. 정규화된 데이터의 경우 로그 변환한 다음 정규 분포(gaussianff)를 사용하는 것을 권장합니다. edgeR과 유사하게 이 방법은 GLM 프레임워크를 사용하므로 이론적으로 배치를 설명할 수 있지만 실제로는 이 데이터 세트에 대해 배치를 포함하면 모델이 실패합니다.

```{r de-real12, fig.cap="Monocle에 대한 ROC 곡선.", message=FALSE, warning=FALSE}
#pd <- data.frame(group = group, batch = batch)
#rownames(pd) <- colnames(counts)
#pd <- new("AnnotatedDataFrame", data = pd)
#
#Obj <- newCellDataSet(
#    as.matrix(counts), 
#    phenoData = pd, 
#    expressionFamily = negbinomial.size()
#)
#Obj <- estimateSizeFactors(Obj)
#Obj <- estimateDispersions(Obj)
#res <- differentialGeneTest(Obj, fullModelFormulaStr = "~group")
#
#pVals <- res[,3]
#names(pVals) <- rownames(res)
#pVals <- p.adjust(pVals, method = "fdr")
#DE_Quality_AUC(pVals)
```

__연습__: 카운트에 대한 음의 이항 모델을 사용한 결과와 로그 변환된 정규화된 카운트에 대한 정규/가우시안 모델(`gaussianff()`)을 사용한 결과를 비교합니다.

<details><summary>답</summary>
```{r de-real13, fig.cap="Monocle-gaussian에 대한 ROC 곡선.", message=FALSE, echo=FALSE, warning=FALSE}
#pd <- data.frame(group = group, batch = batch)
#rownames(pd) <- colnames(norm)
#pd <- new("AnnotatedDataFrame", data = pd)
#
#Obj_log <- newCellDataSet(
#    as.matrix(log(norm + 1) / log(2)), 
#    phenoData = pd, 
#    expressionFamily = gaussianff()
#)
#Obj_log <- estimateSizeFactors(Obj_log)
# Obj_log <- estimateDispersions(Obj_log)
#res <- differentialGeneTest(Obj_log, fullModelFormulaStr = "~group")
#
#pVals <- res[,3]
#names(pVals) <- rownames(res)
#pVals <- p.adjust(pVals, method = "fdr")
#DE_Quality_AUC(pVals)
```
</details>
-->

### MAST

[MAST](https://bioconductor.org/packages/release/bioc/html/MAST.html)는 0-과잉 음의 이항 모델을 기반으로 합니다. 허들 모델을 사용하여 유전자 발현의 이산적(0 대 0이 아님) 및 연속적(0이 아닌 값) 측면의 검정을 결합하여 차등 발현을 검정합니다. 다시 말하지만, 이는 복잡한 모델을 고려할 수 있도록 선형 모델링 프레임워크를 사용합니다.

```{r de-real14, fig.cap="MAST에 대한 ROC 곡선.", message=FALSE}
log_counts <- log(counts + 1) / log(2)
fData <- data.frame(names = rownames(log_counts))
rownames(fData) <- rownames(log_counts);
cData <- data.frame(cond = group)
rownames(cData) <- colnames(log_counts)

obj <- FromMatrix(as.matrix(log_counts), cData, fData)
colData(obj)$cngeneson <- scale(colSums(assay(obj) > 0))
cond <- factor(colData(obj)$cond)

# 조건 및 검출된 유전자 수의 함수로 발현 모델링
zlmCond <- zlm(~ cond + cngeneson, obj) 

summaryCond <- summary(zlmCond, doLRT = "condNA19239")
summaryDt <- summaryCond$datatable

summaryDt <- as.data.frame(summaryDt)
pVals <- unlist(summaryDt[summaryDt$component == "H",4]) # H = 허들 모델
names(pVals) <- unlist(summaryDt[summaryDt$component == "H",1])
pVals <- p.adjust(pVals, method = "fdr")
DE_Quality_AUC(pVals)
```

### 느린 방법(실행 시간 > 1시간)

이러한 방법은 오늘 실행하기에는 너무 느리지만 직접 시도해 보는 것이 좋습니다.

### BPSC

[BPSC](https://academic.oup.com/bioinformatics/article/32/14/2128/2288270/Beta-Poisson-model-for-single-cell-RNA-seq-data)는 이전 장에서 논의한 단일 세포 유전자 발현의 포아송-베타 모델을 사용하며, 이를 edgeR을 사용할 때 이미 접했던 일반화 선형 모델과 결합합니다. BPSC는 하나 이상의 그룹을 참조 그룹("대조군")과 비교하고 모델에 배치와 같은 다른 요인을 포함할 수 있습니다.

```{r de-real15, message=FALSE, eval=FALSE}
library(BPSC)
bpsc_data <- norm[,batch=="NA19101.r1" | batch=="NA19239.r1"]
bpsc_group = group[batch=="NA19101.r1" | batch=="NA19239.r1"]

control_cells <- which(bpsc_group == "NA19101")
design <- model.matrix(~bpsc_group)
coef=2 # 그룹 레이블
res=BPglm(data=bpsc_data, controlIds=control_cells, design=design, coef=coef, 
                estIntPar=FALSE, useParallel = FALSE)
pVals = res$PVAL
pVals <- p.adjust(pVals, method = "fdr")
DE_Quality_AUC(pVals)
```

### SCDE

[SCDE](http://hms-dbmi.github.io/scde/)는 최초의 단일 세포 특이적 DE 방법입니다. 베이지안 통계를 사용하여 0-과잉 음의 이항 모델을 발현 데이터에 피팅합니다. 아래 사용법은 그룹 간의 개별 유전자의 평균 발현 차이를 테스트하지만 최근 버전에는 일반적으로 경로를 나타내는 유전자 그룹의 평균 발현 또는 분산 차이를 테스트하는 방법이 포함됩니다.

```{r de-real16, eval=FALSE}
library(scde)
cnts <- apply(
    counts,
    2,
    function(x) {
        storage.mode(x) <- 'integer'
        return(x)
    }
)
names(group) <- 1:length(group)
colnames(cnts) <- 1:length(group)
o.ifm <- scde::scde.error.models(
    counts = cnts,
    groups = group,
    n.cores = 1,
    threshold.segmentation = TRUE,
    save.crossfit.plots = FALSE,
    save.model.plots = FALSE,
    verbose = 0,
    min.size.entries = 2
)
priors <- scde::scde.expression.prior(
    models = o.ifm,
    counts = cnts,
    length.out = 400,
    show.plot = FALSE
)
resSCDE <- scde::scde.expression.difference(
    o.ifm,
    cnts,
    priors,
    groups = group,
    n.randomizations = 100,
    n.cores = 1,
    verbose = 0
)
# Z-점수를 양측 p-값으로 변환
pVals <- pnorm(abs(resSCDE$cZ), lower.tail = FALSE) * 2
DE_Quality_AUC(pVals)
```

### sessionInfo()

<details><summary>세션 정보 보기</summary>
```{r echo=FALSE}
sessionInfo()
```
</details>