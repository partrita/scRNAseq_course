---
output: html_document
---

# 원시 scRNA-Seq 시퀀싱 데이터 처리: 리드에서 카운트 행렬까지

```{r Intro0, echo=FALSE}
library(knitr)
opts_chunk$set(cache = TRUE, fig.align = "center", echo=FALSE)
```

## 참조 게놈 및 주석

대부분의 scRNA-seq 실험은 인간 또는 마우스 조직, 오가노이드 또는 세포 배양을 사용하여 수행됩니다. 이러한 게놈의 초안이 약 20년 전에 발표되었음에도 불구하고 어셈블리 및 주석 업데이트는 상당히 정기적으로 발생합니다. 어셈블리 파일의 두 가지 인기 있는 소스는 UCSC(어셈블리 이름은 hg19, hg38, mm10 등)와 GRC(GRCh37, GRCh38, GRCm38)입니다. UCSC 및 GRC 어셈블리의 주요 릴리스는 주요 염색체에서 일치하지만(예: hg38의 chr1 = GRCh38의 chr1), 마이너 릴리스 간에 변경되는 추가 컨티그 및 소위 ALT 유전자좌에서 다릅니다(예: GRCh38.p13). 자세한 정보는 [여기](https://www.ncbi.nlm.nih.gov/grc/human) 및 [여기](https://lh3.github.io/2017/11/13/which-human-reference-genome-to-use)에서 얻을 수 있습니다. 게놈 어셈블리는 일반적으로 시퀀스 이름과 시퀀스를 포함하는 간단한 텍스트 파일인 fasta 파일로 배포됩니다.

게놈 주석 프로세스에는 게놈의 전사된 영역(유전자)을 정의하고, 엑손-인트론 경계로 정확한 전사체를 주석 처리하고, 새로 정의된 특징에 단백질 코딩, 비코딩 등과 같은 유형을 할당하는 것이 포함됩니다. 아래 예는 5개의 전사체로 구성된 하나의 유전자를 보여줍니다. 3개는 단백질 코딩(빨간색)이고 2개는 비코딩(파란색)입니다. 게놈 주석은 일반적으로 계층적으로 구성된 [GTF 또는 GFF3 파일 형식](https://ensembl.org/info/website/upload/gff.html)으로 제공됩니다. 각 유전자는 고유한 유전자 ID로 정의됩니다. 각 전사체는 고유한 전사체 ID와 속한 유전자로 정의됩니다. 엑손, UTR 및 코딩 서열은 차례로 특정 전사체에 할당됩니다.

```{r Read-quant1,fig.cap="전형적인 진핵생물 유전자의 전사체 및 인트론-엑손 구조",out.width = '100%'}
knitr::include_graphics("figures/read_quant_1.png")
```

인간 및 마우스 게놈 주석의 인기 있는 소스는 [RefSeq](https://www.ncbi.nlm.nih.gov/refseq/), [ENSEMBL](https://ensembl.org/Homo_sapiens/Info/Annotation) 및 [GENCODE](https://www.gencodegenes.org/)입니다. RefSeq는 세 가지 중 가장 보수적이며 유전자당 주석이 달린 전사체가 가장 적은 경향이 있습니다. RefSeq 전사체 ID는 NM_ 또는 NR로 시작합니다(예: **NM_12345**). ENSEMBL과 GENCODE는 서로 매우 유사하며 우리의 목적을 위해 상호 교환적으로 사용할 수 있습니다. 이러한 유전자 이름은 인간의 경우 ENSG로, 마우스의 경우 ENSMUSG로 시작합니다. 전사체는 각각 ENST 및 ENSMUST로 시작합니다.

유전자 ID 외에도 대부분의 유전자에는 일반적인 이름("유전자 기호")이 할당되어 있습니다. 예를 들어 인간 액틴 B는 앙상블 유전자 ID **ENSG00000075624**와 기호 *ACTB*를 갖습니다. 인간 유전자 이름은 [HGNC](https://www.genenames.org/)에 의해 정기적으로 업데이트되고 정의됩니다. 마우스 유전자 이름은 유사한 컨소시엄인 [MGI](http://www.informatics.jax.org/mgihome/nomen/)에 의해 결정됩니다.

현재 인간 게놈의 ENSEMBL/GENCODE 주석에는 약 60k개의 유전자가 포함되어 있으며 그 중 20k개는 단백질 코딩이고 237k개의 전사체가 있습니다. 대부분의 유전자는 유형별로 단백질 코딩 유전자, 긴 비코딩 RNA, 짧은 비코딩 RNA 및 유사 유전자로 크게 나눌 수 있습니다. 더 높은 해상도에서는 40개 이상의 생물형이 정의됩니다. 유전자 생물형 주석도 주석 버전 간에 종종 변경됩니다(아래 참조).

```{r Read-quant2, fig.cap="GENCODE 버전의 유전자 유형 변경에 대한 Sankey 다이어그램", out.width = '100%'}
knitr::include_graphics("figures/read_quant_2.png")
```

## 대량 RNA-seq 및 전장 scRNA-seq 데이터 처리

대량 RNA-seq의 원시 리드 처리는 일반적으로 리드 정렬과 리드 카운팅의 두 단계로 수행됩니다. 두 단계 모두 개별 유전자의 발현 추정치에 큰 영향을 미칠 수 있는 중요한 주의 사항을 포함합니다. 리드 정렬은 게놈 또는 전사체 참조에 대해 수행할 수 있습니다. 동물 게놈에서 광범위한 스플라이싱으로 인해 게놈에 대한 리드 정렬은 스플라이스 인식 정렬기로 수행해야 합니다. 가장 인기 있는 두 가지 현대적인 도구는 [STAR](https://github.com/alexdobin/STAR)와 [hisat2](https://daehwankimlab.github.io/hisat2/)입니다. 일반적인 리드 적용 범위는 아래 패널 A에 나와 있습니다. 리드 적용 범위는 주어진 유전자의 3' 및 5' 말단 모두에서 비교적 균일합니다. 일부 리드는 1개 이상의 위치에 완벽하게 정렬됩니다. 이러한 리드는 종종 다중 매퍼라고 합니다. 많은 전사체가 서로 매우 유사하기 때문에(예: 하나의 엑손만 다름) 전사체에 정렬할 때 모호성이 훨씬 더 크지만 유전자 수준에서도 눈에 띕니다(아래 패널 B).

```{r Read-quant3, fig.cap="A: 대량 RNA-seq 또는 Smart-seq2 실험의 일반적인 리드 적용 범위; B: 리드가 특징에 할당될 때 발생하는 모호성 유형", out.width = '100%'}
knitr::include_graphics("figures/read_quant_3.png")
```

게놈 또는 전사체에 정렬한 후 리드 카운트는 유전자 또는 전사체 수준에서 요약할 수 있습니다. 게놈 정렬의 경우 가장 간단한 전략은 고유한 위치에 매핑되는 리드(다중 매퍼가 아님)만 계산하고 하나의 유전자만 겹치는 것입니다. 그러나 이것은 필연적으로 유전자 발현 추정치에 편향을 만듭니다(Pachter, 2011). 다소 더 발전된 전략에는 정렬되는 특징 간에 리드 카운트를 분할하는 것이 포함됩니다(예: 리드가 3개의 상동 유전자에 동일하게 잘 정렬되면 각 상동 유전자는 1/3의 카운트를 얻습니다). 가닥 특이적 RNA-seq는 반대 가닥에 위치한 겹치는 특징의 경우 리드 할당의 모호성을 줄입니다. 위에서 언급한 모든 계산 방법을 효율적으로 구현하는 프로그램의 예는 [Subread 패키지](http://subread.sourceforge.net)의 [featureCounts](http://bioinf.wehi.edu.au/featureCounts/)입니다.

전사체 정렬이 사용될 때 리드 할당 모호성은 단순한 계산에는 너무 큽니다. 따라서 전사체당 및 유전자당 풍부도는 [기대값-최대화](https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm)(EM) 알고리즘을 사용하여 최대 우도 풍부도 추정치를 사용하여 계산됩니다. 이 접근 방식은 리드의 다양한 부분이 매핑되는 특징에 할당되도록 하고 다중 매퍼와 관련된 편향을 상당히 줄입니다. 전사체에 할당된 리드(및 리드 분수)는 유전자 수준에서 요약됩니다. 이 전략을 구현하는 가장 널리 사용되고 잘 지원되는 프로그램은 [RSEM](https://github.com/deweylab/RSEM)입니다. 일반적으로 이것은 대량 RNA-seq 정량화의 가장 정확한 방법입니다(Pachter, 2011).

위에서 설명한 기존 접근 방식(정렬 후 리드 정량화)의 대안은 소위 의사 정렬 방법을 기반으로 합니다. 두 가지 인기 있는 도구인 [kallisto](https://pachterlab.github.io/kallisto/)와 [salmon](https://salmon.readthedocs.io/en/latest/salmon.html)은 매우 유사한 접근 방식을 사용합니다.

  * 참조 전사체를 k-mer로 분할하고 De Bruijn 그래프를 만듭니다.
  * RNA-seq 리드를 k-mer로 변환합니다.
  * k-mer를 사용하여 리드를 전사체 또는 여러 전사체("등가 클래스")에 할당합니다.
  * 결과 카운트를 전사체 또는 유전자 수준에서 요약합니다.
  
기대값-최대화 알고리즘은 여러 전사체에 매핑되는 리드의 최적 분포를 찾는 데 사용됩니다. 두 도구 모두 매우 메모리 및 CPU 효율적이며 특히 페어드 엔드 또는 긴 단일 엔드 리드에 대해 매우 정확합니다. 의사 정렬은 정렬 BAM 파일을 생성하지 않으므로 시각화가 필요한 경우(예: 전사체 주석에 RNA-seq를 사용할 때) 정렬도 별도로 수행해야 합니다.

```{r Read-quant4, fig.cap="전사체 De Bruijn 그래프에 대한 의사 정렬", out.width = '100%'}
knitr::include_graphics("figures/read_quant_4.png")
```

대량 RNA-seq 정량화에 대해 몇 가지 사항을 유의해야 합니다. 첫째, 시퀀싱된 cDNA 단편의 수는 세포에 존재하는 RNA의 양에 비례한다고 일반적으로 가정합니다. 따라서 페어드 엔드 리드를 사용할 때 각 리드 쌍은 동일한 cDNA 단편에서 비롯되므로 한 번만 계산됩니다. 인간 및 마우스와 같이 잘 주석이 달린 게놈의 경우 RNA-seq에 단일 엔드 리드를 사용하는 것이 매우 일반적입니다. 둘째, PCR 중복은 일반적으로 대량 RNA-seq에서 무시되며 UMI 사용도 상당한 이점을 제공하지 않습니다. 여러 독립적인 연구에 따르면 중복 제거 또는 UMI 사용은 대량 RNA-seq의 통계적 검정력을 눈에 띄게 증가시키지 않습니다.

마지막으로, 많은 차등 발현 방법이 원시 리드 카운트를 사용하지만 클러스터링, PCA 및 기타 유형의 탐색 분석을 수행할 때 샘플 내 정규화를 사용하는 것이 일반적입니다. 이러한 정규화의 가장 인기 있는 방법은 원시 리드를 [백만 분의 전사체](https://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained)(TPM)로 변환하는 것입니다. 변환은 두 가지 편향을 고려합니다. 1) 다른 샘플은 유전자 발현 차이와 직접적으로 관련이 없는 다른 깊이로 시퀀싱됩니다. 2) 긴 유전자는 짧은 유전자보다 더 많은 cDNA 단편을 생성할 것으로 예상됩니다. 따라서 TPM 계산을 위해 원시 리드 카운트는 먼저 유효 전사체 길이로 나뉘며, 이는 전사체 길이 - cDNA 단편 크기 + 1로 정의됩니다. 이 후 결과 숫자는 선형적으로 확장되어 백만에 합산됩니다. 따라서 특정 샘플의 모든 TPM 값의 합은 항상 (대략) 1,000,000과 같습니다.

## 방울 기반 scRNA-seq 데이터의 리드 정렬 및 정량화

### 일반적인 고려 사항

단일 세포 RNA-seq 데이터는 여러 면에서 대량 RNA seq와 다릅니다(위의 단일 세포 RNA-Seq 소개 장 참조). 대부분의 최신 scRNA-seq 기술은 세 가지 주요 정보 조각을 포함하는 리드 서열을 생성합니다.

  * RNA 전사체를 식별하는 cDNA 단편;
  * RNA가 발현된 세포를 식별하는 세포 바코드(CB);
  * PCR 중복인 리드를 축소할 수 있는 고유 분자 식별자(UMI).
  
대량 RNA-seq와 달리 scRNA-seq는 훨씬 적은 양의 RNA를 처리하며 더 많은 PCR 주기가 수행됩니다. 따라서 UMI 바코드는 매우 유용하며 현재 scRNAseq에서 널리 받아들여지고 있습니다. 라이브러리 시퀀싱은 종종 페어드 엔드 리드로 수행되며, 한 리드는 CB + UMI를 포함하고(10x Chromium의 리드 1), 다른 리드는 실제 전사체 서열을 포함합니다(10x Chromium의 리드 2).

고전적인 scRNA-seq 워크플로에는 네 가지 주요 단계가 포함됩니다.

  * cDNA 단편을 참조에 매핑;
  * 리드를 유전자에 할당;
  * 리드를 세포에 할당(세포 바코드 다중 분리);
  * 고유한 RNA 분자 수 계산(UMI 중복 제거).
  
이 절차의 결과는 유전자/세포 카운트 행렬이며, 이는 각 유전자에 대한 각 세포의 RNA 분자 수의 추정치로 사용됩니다.

### Cell Ranger의 리드 매핑

[Cell Ranger](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger)는 10x Genomics Chromium scRNAseq 데이터를 처리하기 위한 기본 도구입니다. STAR 정렬기를 사용하며, 이는 게놈에 대한 리드의 스플라이싱 인식 정렬을 수행합니다. 이 후 전사체 주석 GTF를 사용하여 리드를 엑손, 인트론 및 유전자간으로 버킷화하고 리드가 게놈에 (확신을 가지고) 정렬되는지 여부로 버킷화합니다. 리드는 50% 이상이 엑손과 교차하면 엑손이고, 엑손이 아니고 인트론과 교차하면 인트론이며, 그렇지 않으면 유전자간입니다(아래 참조). 리드 유형 할당 후 매핑 품질 조정이 수행됩니다. 단일 엑손 유전자좌에 정렬되지만 1개 이상의 비엑손 유전자좌에도 정렬되는 리드의 경우 엑손 유전자좌가 우선 순위가 지정되고 리드는 엑손 유전자좌에 확실하게 매핑된 것으로 간주되어 최대 매핑 품질 점수가 부여됩니다.

```{r Read-quant5, fig.cap="Cell Ranger에서 정렬된 리드의 분류", out.width = '100%'}
knitr::include_graphics("figures/read_quant_5.png")
```

`Cell Ranger`는 전사체와의 호환성을 검사하여 엑손 및 인트론 확실하게 매핑된 리드를 주석이 달린 전사체에 추가로 정렬합니다. 리드는 센스 또는 안티센스인지 여부와 엑손, 인트론인지 또는 스플라이싱 패턴이 해당 유전자와 관련된 전사체 주석과 호환되는지 여부를 기준으로 분류됩니다. 기본적으로 전사체(위 그림의 파란색)인 리드는 UMI 계산으로 전달됩니다.

분석에 대한 입력이 핵으로 구성된 경우 리드의 높은 비율은 미접합 전사체에서 유래하며 인트론에 정렬됩니다. 이러한 인트론 리드를 계산하기 위해 "cellranger count" 및 "cellranger multi" 파이프라인은 include-introns 옵션으로 실행할 수 있습니다. 이 옵션을 사용하면 단일 유전자에 센스 방향으로 매핑되는 모든 리드(위 다이어그램에서 전사체(파란색), 엑손(밝은 파란색) 및 인트론(빨간색)으로 표시된 리드 포함)가 UMI 계산으로 전달됩니다. include-introns 옵션은 전체 유전자 본체를 엑손으로 정의하는 사용자 지정 "pre-mRNA" 참조의 필요성을 제거합니다.
중요하게도, 리드는 단일 유전자와만 호환되는 경우 고유하게 매핑된 것으로 간주됩니다. 고유하게 매핑된 리드만 UMI 계산으로 전달됩니다. 다중 매핑 리드는 `Cell Ranger`에 의해 폐기됩니다. 웹 요약 HTML 출력에서 UMI 계산으로 전달된 리드 세트는 "전사체에 확실하게 매핑된 리드"라고 합니다.

### Cell Ranger 참조 준비

참조 처리의 세부 사항을 살펴보기 전에 기본 `Cell Ranger` 인간 및 마우스 참조가 어떻게 준비되는지 주목하는 것이 중요합니다. [기본 게놈 어셈블리](https://www.ncbi.nlm.nih.gov/grc/help/definitions) 버전(즉, ALT 유전자좌 제외)은 모든 버전에서 정렬에 사용됩니다. 주석 GTF 파일은 [여기](https://support.10xgenomics.com/single-cell-gene-expression/software/release-notes/build#header)에서 찾을 수 있는 스크립트를 사용하여 필터링됩니다. 다음 생물형이 유지됩니다: 단백질 코딩, 긴 비코딩 RNA, 안티센스 및 BCR/TCR(즉, V/D/J) 유전자에 속하는 모든 생물형(이전 `Cell Ranger` 참조 버전에는 후자가 포함되지 않음). 모든 유사 유전자 및 작은 비코딩 RNA는 제거됩니다.

소프트웨어와 함께 사전 패키징된 여러 버전의 `Cell Ranger` 참조가 있습니다. 2020-A는 현재까지 최신 버전의 참조입니다. 이전에 `Cell Ranger`에서 사용한 모든 개별 어셈블리 및 주석 조합은 아래에 나열되어 있습니다. 각 참조를 사용하여 생성된 필터링되지 않은 scRNAseq 발현 행렬은 "필터링 후 유전자" 열의 값과 동일한 행 수를 포함할 것으로 예상됩니다. 또한 `Cell Ranger`에는 인간과 마우스 세포를 모두 포함하는 실험에 유용한 인간 + 마우스 결합 참조도 포함되어 있습니다.


| Cell Ranger 참조 | 종 | 어셈블리/주석 | 필터링 전 유전자 | 필터링 후 유전자 |
|:-:|:-:|:-:|:-:|:-:|
| 2020-A | 인간 | GRCh38/GENCODE v32 | 60668 | 36601 |
| 2020-A | 마우스 | mm10/GENCODE vM23 | 55421 | 32285 |
| 3.0.0 | 인간 | GRCh38/Ensembl 93 | 58395 | 33538 |
| 3.0.0 | 인간 | hg19/Ensembl 87 | 57905 | 32738 |
| 3.0.0 | 마우스 | mm10/Ensembl 93 | 54232 | 31053 |
| 2.1.0 | 마우스 | mm10/Ensembl 84 | 47729 | 28692 |
| 1.2.0 | 인간 | GRCh38/Ensembl 84 | 60675 | 33694 |
| 1.2.0 | 인간 | hg19/Ensembl 82 | 57905 | 32738 |
| 1.2.0 | 마우스 | mm10/Ensembl 84 | 47729 | 27998 |


### Chromium 버전 및 세포 바코드 화이트리스트

세포 바코드 서열은 개별 세포를 식별하는 비드에 부착된 합성 서열입니다. 고유한 서열 라이브러리는 화이트리스트라고 하며 Chromium 라이브러리 준비 키트 버전에 따라 다릅니다. 화이트리스트 파일은 [Cell Ranger 저장소](https://github.com/10XGenomics/cellranger/tree/master/lib/python/cellranger/barcodes)에서 사용할 수 있습니다. Chromium에 사용되는 세 가지 화이트리스트가 있습니다: `737K-april-2014_rc.txt`, `737K-august-2016.txt` 및 `3M-february-2018.txt`. 첫 번째 목록의 CB는 14bp이고 다른 두 개는 16bp입니다. 아래 표는 인기 있는 10x 단일 세포 시퀀싱 키트에 대한 세포 바코드 및 UMI 길이와 적절한 화이트리스트 파일을 제공합니다.


| 화학 | CB, bp | UMI, bp | 화이트리스트 파일 |
|:-:|:-:|:-:|:-:|
| 10x Chromium 단일 세포 3' v1 | 14 | 10 | 737K-april-2014_rc.txt |
| 10x Chromium 단일 세포 3' v2 | 16 | 10 | 737K-august-2016.txt |
| 10x Chromium 단일 세포 3' v3 | 16 | 12 | 3M-february-2018.txt |
| 10x Chromium 단일 세포 3' v3.1 (Next GEM) | 16 | 12 | 3M-february-2018.txt |
| 10x Chromium 단일 세포 5' v1.1 | 16 | 10 | 737K-august-2016.txt |
| 10x Chromium 단일 세포 5' v2 (Next GEM) | 16 | 10 | 737K-august-2016.txt |
| 10x Chromium 단일 세포 Multiome | 16 | 12 | 737K-arc-v1.txt |


Cell Ranger는 [다음 알고리즘](https://kb.10xgenomics.com/hc/en-us/articles/115003822406-How-does-Cell-Ranger-correct-barcode-sequencing-errors-)을 사용하여 화이트리스트에 대해 추정되는 바코드 서열을 수정합니다.

  * 데이터 세트에서 화이트리스트에 있는 모든 바코드의 관찰된 빈도를 계산합니다.
  * 데이터 세트에서 화이트리스트에 없는 모든 관찰된 바코드에 대해 1-해밍 거리에 있는 화이트리스트 서열을 찾습니다. 각 서열에 대해:
      * 관찰된 바코드가 다른 염기에 시퀀싱 오류가 있는 화이트리스트 바코드에서 유래했을 후방 확률을 계산합니다(염기 Q 점수 기준).
      * 관찰된 바코드를 0.975를 초과하는 가장 높은 후방 확률을 가진 화이트리스트 바코드로 교체합니다.
      
수정된 바코드는 모든 다운스트림 분석 및 출력 파일에 사용됩니다. 출력 BAM 파일에서 원래 수정되지 않은 바코드는 CR 태그에 인코딩되고 수정된 바코드 서열은 CB 태그에 인코딩됩니다. 수정된 바코드를 할당할 수 없는 리드에는 CB 태그가 없습니다.
3M-february-2018.txt 파일에 실제로 6백만 개가 넘는 고유한 서열이 포함된 이유에 대한 설명은 [여기](https://kb.10xgenomics.com/hc/en-us/articles/360031133451-Why-is-there-a-discrepancy-in-the-3M-february-2018-txt-barcode-whitelist-)에서 찾을 수 있습니다.

### UMI 계산

일반적으로 "UMI 계산"이라고 하는 것은 리드 계산과 UMI 서열을 기반으로 한 PCR 중복 축소로 구성됩니다. UMI를 계산하기 전에 Cell Ranger는 UMI 서열의 시퀀싱 오류를 수정하려고 시도합니다. 전사체에 확실하게 매핑된 리드는 동일한 바코드, UMI 및 유전자 주석을 공유하는 그룹으로 배치됩니다. 두 리드 그룹이 동일한 바코드와 유전자를 가지고 있지만 UMI가 단일 염기로 다른 경우(즉, [해밍 거리](https://en.wikipedia.org/wiki/Hamming_distance)가 1인 경우) UMI 중 하나는 시퀀싱에서 대체 오류로 인해 도입되었을 가능성이 높습니다. 이 경우 덜 지원되는 리드 그룹의 UMI는 더 높은 지원을 받는 UMI로 수정됩니다.

Cell Ranger는 다시 바코드, UMI(수정 가능) 및 유전자 주석으로 리드를 그룹화합니다. 두 개 이상의 리드 그룹이 동일한 바코드와 UMI를 가지고 있지만 다른 유전자 주석을 가지고 있는 경우 가장 많은 지원 리드를 가진 유전자 주석이 UMI 계산을 위해 유지되고 다른 리드 그룹은 폐기됩니다. 최대 리드 지원에 대한 동점인 경우 모든 리드 그룹은 유전자를 확실하게 할당할 수 없으므로 폐기됩니다.

이 두 필터링 단계 후 각 관찰된 바코드, UMI, 유전자 조합은 필터링되지 않은 특징-바코드(즉, 유전자-세포) 행렬에 UMI 카운트로 기록됩니다. 각 계산된 UMI를 지원하는 리드 수는 분자 정보 파일에도 기록됩니다.

### 세포 필터링

필터링되지 않은("원시") 특징-바코드 행렬에는 실제로 빈 방울인 많은 열이 포함되어 있습니다. 이러한 방울의 유전자 발현 카운트는 깨진 세포의 주변 RNA 존재와 같은 기술적 노이즈로 인해 0이 아닙니다. 그러나 일반적으로 존재하는 RNA의 양에 의해 *bona fide* 세포와 구별할 수 있습니다. `Cell Ranger`에는 이 세포 필터링을 위해 구현된 두 가지 알고리즘이 있으며, 이를 "Cell Ranger 2.2" 및 "Cell Ranger 3.0" 필터링이라고 합니다.

원래 알고리즘(Cell Ranger 2.2)은 "바코드 카운트 대 바코드당 UMI" 플롯에서 첫 번째 "무릎 지점"을 식별했습니다. Cell Ranger 3.0은 낮은 RNA 함량 세포 집단을 더 잘 식별할 수 있는 개선된 세포 호출 알고리즘을 도입했습니다. 특히 낮은 RNA 함량 세포가 높은 RNA 함량 세포 집단에 혼합된 경우에 그렇습니다. 예를 들어, 종양 샘플에는 종종 작은 종양 침윤 림프구(TIL)와 혼합된 큰 종양 세포가 포함되어 있으며 연구자들은 특히 TIL 집단에 관심이 있을 수 있습니다. 새로운 알고리즘은 EmptyDrops 방법(Lun et al., 2018)을 기반으로 합니다.

```{r Read-quant6, fig.cap="Cell Ranger 2.2 및 3.0 필터링 알고리즘에 의해 식별된 무릎 플롯 및 빈 방울 컷오프", out.width = '100%'}
knitr::include_graphics("figures/read_quant_6.png")
```

### 의사 정렬 기반 방법

의사 정렬(위 참조)은 scRNA-seq 데이터 세트를 신속하게 정량화하는 데에도 사용할 수 있습니다. 현재 이 접근 방식을 구현하는 두 가지 소프트웨어 제품군이 있습니다: [kallisto/BUStools](https://www.kallistobus.tools/) 및 [Salmon/Alevin/Alevin-fry](https://salmon.readthedocs.io/en/latest/alevin.html). 모듈식 접근 방식을 유지하기 위해 두 생태계 모두 정량화 결과를 저장할 수 있는 자체 형식을 도입했습니다. `kallisto`/`BUStools`는 BUS(바코드, UMI 및 세트) 파일 형식을 도입했으며(Melsted et al, 2019), `Alevin`/`Alevin-fry`는 동일한 목적으로 RAD 형식을 사용하고 있습니다(Srivastava et al, 2019).

`kallisto`/`BUStools`와 `Alevin`/`Alevin-fry` 모두 세포 바코드 및 UMI 오류 수정 및 다중 분리를 위한 자체 알고리즘을 구현합니다. 예를 들어 `Alevin`은 세포 바코드 화이트리스트를 요구하지 않지만 사용할 수 있습니다. 그러나 정렬 기반 방법과의 가장 큰 차이점은 의사 정렬의 정확도가 낮고 다중 매핑 리드가 포함된다는 점입니다.

`kallisto`/`BUStools`는 CEL-seq, CEL-seq2 및 SMART-seq와 같은 저처리량 기술을 포함한 많은 시퀀싱 기술을 지원합니다. 지원되는 실험의 전체 목록은 `kb --list`로 인쇄할 수 있습니다. `Alevin`은 현재 가장 인기 있는 두 가지 방울 기반 단일 세포 프로토콜인 Drop-seq와 10x Chromium만 지원합니다.

일반적으로 `kallisto`/`BUStools` 및 `Alevin`은 매우 효율적이어서 2-4Gb의 RAM으로 인간 또는 마우스 데이터 세트를 처리할 수 있으며 `Cell Ranger`보다 최소한 한 자릿수 빠릅니다. 두 도구 모두 다중 매핑 리드를 올바르게 처리하여 영향을 받는 유전자에 대한 정량화 편향을 줄입니다. 그러나 여러 간행물에서 의사 정렬 기반 방법이 유지된 인트론의 리드를 전사체에 잘못 매핑한다고 지적했습니다(Melsted et al, 2021; Srivastava et al, 2020). scRNA-seq 실험, 특히 단일 핵 RNA-seq는 유지된 인트론이 있는 전사체의 비율이 매우 높을 수 있다는 것은 [잘 알려져 있습니다](https://t.co/maED24oFeA?amp=1). 이 잘못된 할당은 수백 개의 비발현 유전자를 약하게 발현되는 것처럼 보이게 만들어 다운스트림 분석, 특히 마커 선택에 상당한 영향을 미칠 수 있습니다(Kaminow et al, 2021). 따라서 `Cell Ranger`보다 최소한 정확하고 훨씬 빠른 방법을 개발하려는 노력이 여전히 있습니다.

## STARsolo 및 Alevin-full-decoy: 고속 및 고정밀

`STARsolo`는 이 장에서 이전에 언급한 `STAR` RNA-seq 정렬기의 일부인 독립 실행형 파이프라인입니다. `Cell Ranger`와 매우 유사한 결과를 생성하면서 계산적으로 효율적으로 유지하는 것을 목표로 개발되었습니다. 일반적으로 `STARsolo`는 동일한 데이터 세트에서 `Cell Ranger`보다 몇 배 빠릅니다. UMI 축소, 세포 바코드 다중 분리 및 세포 필터링을 위한 `STARsolo` 방법은 `Cell Ranger`에서 사용하는 알고리즘을 의도적으로 다시 구현합니다. `STAR` 버전 2.7.9a부터 `STARsolo`는 다중 매핑 리드를 올바르게 정량화할 수 있어 빠르고 정확한 scRNA-seq 처리를 위한 매우 매력적인 옵션이 되었습니다(Kaminow et al, 2021). `STARsolo`의 추가적인 이점은 세포 바코드 및 UMI 검색의 유연한 구현입니다. 리드 내의 상대적 위치와 각 서열의 길이를 알면 대부분의 scRNA-seq 접근 방식으로 생성된 데이터를 처리할 수 있습니다.

`Alevin` 개발자들도 위에서 언급한 인트론 리드 문제를 인식하고 소위 [디코이 서열](https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment)을 사용하는 특별한 솔루션을 개발했습니다. 최근 `STARsolo` 사전 인쇄물에서 전체 게놈 디코이를 사용한 `Alevin`은 `STARsolo` 또는 `Cell Ranger`와 매우 유사한 정확도를 보였습니다(Kaminow et al, 2021).

## 비모델 유기체에 대한 참고 사항

특히 주요 종의 신규 게놈 어셈블리 프로젝트의 일부로 덜 알려진 다세포 유기체의 특성화를 위해 단일 세포 RNA-seq를 사용하는 것이 점점 더 인기를 얻고 있습니다. 여기서 두 가지 중요한 점을 유의해야 합니다. 첫째, 미토콘드리아 리드가 모든 scRNA-seq 라이브러리의 상당 부분을 차지하고 실험 품질 관리에 널리 사용되기 때문에 올바르게 조립되고 잘 주석이 달린 미토콘드리아 서열이 중요합니다(scRNA-seq 소개 참조). 최근의 노력으로 많은 비모델 척추동물에 대해 신중하게 조립된 미토콘드리아 서열의 개요를 모았습니다(Formenti et al, 2021). [MITOS2](http://mitos2.bioinf.uni-leipzig.de/index.py)는 후생동물에 대한 양질의 미토콘드리아 주석을 자동으로 생성하는 데 사용할 수 있는 전문 서버입니다.

둘째, 신규 시퀀싱된 게놈에 대한 대부분의 주석 방법은 UTR 서열을 포함하지 않는 유전자 모델을 생성한다는 점을 유의하는 것이 중요합니다. 3' 및 5' scRNA-seq 방법 모두 유전자의 양쪽 끝을 향한 리드 분포에 심하게 편향되어 있습니다(아래 그림). 따라서 UTR 서열이 없는 유전자 주석을 사용하면 정량화 및 분석 결과가 크게 왜곡됩니다.

```{r Read-quant7, fig.cap="3' 및 5' 10x scRNA-seq 실험의 일반적인 리드 적용 범위", out.width = '100%'}
knitr::include_graphics("figures/read_quant_7.png")
```

## 간략한 요약 및 처리 권장 사항

`Cell Ranger`는 10x Genomics에서 제공하는 기본 소프트웨어 제품군이며 리드 정렬 및 정량화에 가장 널리 사용되는 도구로 남아 있습니다. 생물정보학 경험이 부족하거나 `Cell Ranger`로 처리된 다른 많은 샘플이 있는 경우 계속 사용하십시오. 최신 `Cell Ranger` 버전과 함께 제공되는 최신 주석 파일을 사용하는 것이 좋습니다(위 3.3 참조). 동시에 `STARsolo` 및 `Alevin-full_decoy`는 뛰어난 계산 속도 향상과 다중 매퍼의 올바른 처리를 제공하여 `Cell Ranger`와의 매우 높은 호환성을 유지하면서 정량화 편향을 줄입니다. 터미널 도구에 익숙한 사용자에게는 아마도 최상의 옵션일 것입니다. 마지막으로, 주석이 잘 안된 게놈으로 작업하는 경우 유전자 모델에 UTR이 포함되어 있고 잘 조립되고 주석이 달린 미토콘드리아가 있는지 확인하십시오.