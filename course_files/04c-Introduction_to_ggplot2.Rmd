---
output: html_document
---

```{r ggplot0, echo=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE, cache.extra = list(R.version, sessionInfo()))
```
## ggplot2 소개

### ggplot2란 무엇인가?

ggplot2는 Hadley Wickham이 설계한 R 패키지로 데이터 플로팅을 용이하게 합니다. 이 실습에서는 패키지의 일부 기능에 대해 간략하게 다룰 것입니다. ggplot2 사용 방법에 대해 더 자세히 알고 싶다면 Hadley Wickham의 "ggplot2 Elegant graphics for data analysis"를 읽는 것이 좋습니다.


### ggplot2의 원리

* ggplot2를 사용하여 데이터를 플로팅하려면 데이터가 데이터 프레임이어야 합니다.
* `aes` 매핑 함수를 사용하여 데이터 프레임의 변수가 플롯의 특징에 어떻게 매핑되는지 지정합니다.
* 지옴을 사용하여 데이터를 그래프에 어떻게 표현할지 지정합니다(예: 산점도, 막대 그래프, 상자 그림 등).

### `aes` 매핑 함수 사용하기

`aes` 함수는 데이터 프레임의 변수가 플롯의 특징에 어떻게 매핑되는지 지정합니다. 이것이 어떻게 작동하는지 이해하기 위해 예를 살펴보겠습니다.

```{R ggplot1, eval=TRUE, message=FALSE}
library(ggplot2)
library(tidyverse)
set.seed(1)
counts <- as.data.frame(matrix(rpois(100, lambda = 10), ncol=10, nrow=10))
Gene_ids <- paste("gene", 1:10, sep = "")
colnames(counts) <- paste("cell", 1:10, sep = "")
counts<-data.frame(Gene_ids, counts)
counts
ggplot(data = counts, mapping = aes(x = cell1, y = cell2))
```

마지막 명령인 `ggplot(data = counts, mapping = aes(x = cell1, y = cell2))`를 자세히 살펴보겠습니다. `ggplot()`은 ggplot 객체를 초기화하고 `data`와 `mapping` 인수를 사용합니다. 카운트 데이터 프레임을 `data`에 전달하고 `aes()` 함수를 사용하여 cell1 변수를 x 변수로, cell2 변수를 y 변수로 사용하도록 지정합니다.

과제 1: 위 명령을 수정하여 cell10이 x 변수이고 cell8이 y 변수인 ggplot 객체를 초기화하십시오.

분명히, 우리가 방금 만든 플롯은 데이터가 표시되지 않기 때문에 그다지 유익하지 않습니다. 데이터를 표시하려면 지옴을 사용해야 합니다.

### 지옴

지옴을 사용하여 데이터를 그래프에 어떻게 표시할지 지정할 수 있습니다. 예를 들어, 지옴 선택은 데이터를 산점도, 막대 그래프 또는 상자 그림으로 표시하도록 지정할 수 있습니다.

그래프가 산점도로 어떻게 보이는지 살펴보겠습니다.

```{R ggplot2, eval=TRUE}
ggplot(data = counts, mapping = aes(x = cell1, y = cell2)) + geom_point()
```

이제 cell1과 cell2의 유전자 발현 사이에 상관 관계가 없는 것 같습니다. `counts`를 무작위로 생성했기 때문에 이것은 그다지 놀라운 일이 아닙니다.

과제 2: 위 명령을 수정하여 선 그림을 만듭니다. 힌트: `?ggplot`을 실행하고 도움말 페이지를 아래로 스크롤합니다. 맨 아래에 ggplot 패키지 인덱스에 대한 링크가 있습니다. 지옴 옵션을 찾을 때까지 인덱스를 스크롤합니다.

### 2개 이상의 셀에서 데이터 플로팅하기

지금까지 데이터 프레임의 2개 셀에서 유전자 카운트를 고려했습니다. 그러나 실제로는 데이터 프레임에 10개의 셀이 있으며 모두 비교하는 것이 좋을 것입니다. 10개 셀 모두에서 동시에 데이터를 플로팅하고 싶다면 어떻게 해야 할까요?

지금은 각 개별 셀을 변수로 취급하고 해당 변수를 x 또는 y 축에 할당하기 때문에 이 작업을 수행할 수 없습니다. 10개 셀 모두에서 데이터를 플로팅하기 위해 10차원 그래프를 만들 수 있지만 이것은 a) ggplot으로 수행할 수 없고 b) 해석하기가 쉽지 않습니다. 대신 데이터를 정리하여 셀 ID를 나타내는 변수 하나와 유전자 카운트를 나타내는 변수 하나를 만들고 서로에 대해 플로팅할 수 있습니다. 코드로 나타내면 다음과 같습니다.

```{R ggplot3, eval=TRUE}
counts<-gather(counts, colnames(counts)[2:11], key = 'Cell_ID', value='Counts')
head(counts)
```

본질적으로 이전의 문제는 데이터가 깔끔하지 않았다는 것입니다. 왜냐하면 하나의 변수(Cell_ID)가 여러 열에 걸쳐 있었기 때문입니다. 이제 이 문제를 해결했으므로 한 그래프에 10개 셀 모두에서 데이터를 훨씬 쉽게 플로팅할 수 있습니다.

```{R ggplot4, eval=TRUE}
ggplot(counts,aes(x=Cell_ID, y=Counts)) + geom_boxplot()
```

과제 3: 업데이트된 `counts` 데이터 프레임을 사용하여 Cell_ID를 x 변수로, Counts를 y 변수로 하는 막대 그래프를 플로팅합니다. 힌트: `?geom_bar`를 읽는 것이 도움이 될 수 있습니다.

과제 4: 업데이트된 `counts` 데이터 프레임을 사용하여 Gene_ids를 x 변수로, Counts를 y 변수로 하는 산점도를 플로팅합니다.

### 히트맵 플로팅하기

유전자 발현 데이터를 시각화하는 일반적인 방법은 히트맵을 사용하는 것입니다. 여기서는 R 패키지 `pheatmap`을 사용하여 `test`라는 이름의 일부 유전자 발현 데이터로 이 분석을 수행합니다.

```{R ggplot5, eval=TRUE, message=FALSE}
library(pheatmap)
set.seed(2)
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Cell", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
pheatmap(test)
```

이 그래픽이 무엇을 보여주는지 잠시 살펴보겠습니다. 각 행은 유전자를 나타내고 각 열은 셀을 나타냅니다. 각 셀에서 각 유전자가 얼마나 높게 발현되는지는 해당 상자의 색상으로 표시됩니다. 예를 들어, 이 플롯에서 gene18은 cell10에서 높게 발현되지만 cell1에서는 낮게 발현된다는 것을 알 수 있습니다.

이 플롯은 또한 클러스터링 알고리즘의 결과에 대한 정보도 제공합니다. 일반적으로 클러스터링 알고리즘은 데이터 포인트(예: 셀)를 구성원이 나머지 데이터 포인트보다 서로 더 유사한 그룹으로 분할하는 것을 목표로 합니다. 그래프의 상단과 왼쪽에 그려진 트리는 클러스터링 알고리즘의 결과이며, 예를 들어 셀 4, 8, 2, 6, 10이 셀 7, 3, 5, 1, 9보다 서로 더 유사하다는 것을 알 수 있습니다. 그래프의 왼쪽에 있는 트리는 데이터 세트의 유전자에 적용된 클러스터링 알고리즘의 결과를 나타냅니다.

트리를 자세히 살펴보면 결국 셀과 유전자의 수만큼 가지가 있다는 것을 알 수 있습니다. 즉, 총 셀 클러스터 수는 총 셀 수와 같고 총 유전자 클러스터 수는 총 유전자 수와 같습니다. 분명히 이것은 그다지 유익하지 않으며 10개 이상의 셀과 20개 이상의 유전자를 볼 때 비실용적이 될 것입니다. 다행히도 플롯에 표시되는 클러스터 수를 설정할 수 있습니다. 유전자 클러스터 수를 2로 설정해 보겠습니다.

```{R ggplot6, eval=TRUE}
pheatmap(test, kmeans_k = 2)
```

이제 유전자가 두 개의 클러스터로 나뉘는 것을 볼 수 있습니다. 다른 셀에 비해 셀 2, 10, 6, 4, 8에서 상향 조절된 8개 유전자 클러스터와 다른 셀에 비해 셀 2, 10, 6, 4, 8에서 하향 조절된 12개 유전자 클러스터입니다.

과제 5: 클러스터 수를 3으로 설정해 보십시오. 어떤 클러스터 수가 더 유익하다고 생각하십니까?

### 주성분 분석

주성분 분석(PCA)은 변환을 사용하여 관측치 집합을 주성분이라고 하는 선형적으로 상관되지 않은 변수의 값 집합으로 변환하는 통계적 절차입니다. 변환은 첫 번째 주성분이 데이터의 변동성을 가능한 한 많이 설명하도록 수행되며, 각 후속 주성분은 이전 성분과 직교해야 한다는 제약 조건 하에서 가능한 가장 큰 분산을 설명합니다.

PCA 플롯은 데이터에 대한 개요를 얻는 좋은 방법이며 때로는 데이터의 변동성을 많이 설명하는 교란 요인을 식별하는 데 도움이 될 수 있습니다. 향후 실습에서 단일 세포 RNA-seq 분석에서 PCA 플롯을 어떻게 사용할 수 있는지 더 자세히 조사할 것이며, 여기서는 PCA 플롯이 무엇이며 어떻게 생성되는지에 대한 개요를 제공하는 것을 목표로 합니다.

`test` 데이터에 대한 PCA 플롯을 만들어 보겠습니다. `ggfortify` 패키지를 사용하여 ggplot이 주성분을 어떻게 해석해야 하는지 알려줄 수 있습니다.

```{R ggplot7, eval=TRUE, message=FALSE}
library(ggfortify)
Principal_Components<-prcomp(test)
autoplot(Principal_Components, label=TRUE)
```

과제 6: 클러스터를 pheatmap 클러스터와 비교합니다. 관련이 있습니까? (힌트: 우리가 플로팅한 첫 번째 pheatmap의 유전자 트리를 살펴보십시오)

과제 7: `counts`에 대한 히트맵 및 PCA 플롯을 생성합니다(아래).

```{R ggplot8, eval=TRUE}
set.seed(1)
counts <- as.data.frame(matrix(rpois(100, lambda = 10), ncol=10, nrow=10))
rownames(counts) <- paste("gene", 1:10, sep = "")
colnames(counts) <- paste("cell", 1:10, sep = "")
```