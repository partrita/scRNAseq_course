---
output: html_document
---

# scRNA-seq 데이터 세트 통합

```{r int0, echo=FALSE}
library(knitr)
opts_chunk$set(cache = TRUE, out.width='100%', fig.align = 'center')
```

## 소개

scRNA-seq 데이터 세트가 점점 더 많아짐에 따라 이들 간의 merged_seurat 비교를 수행하는 것이 중요합니다. scRNASeq 데이터 세트를 비교하는 데는 두 가지 주요 접근 방식이 있습니다. 첫 번째 접근 방식은 개별 세포 또는 세포 그룹을 비교하여 데이터 세트 전체에서 동등한 세포 유형/상태를 식별하는 데 초점을 맞춘 "레이블 중심"입니다. 다른 접근 방식은 여러 실험의 데이터를 결합하고 공동으로 분석할 수 있도록 실험별 기술적/생물학적 효과를 계산적으로 제거하려고 시도하는 "교차 데이터 세트 정규화"입니다.

레이블 중심 접근 방식은 신뢰도가 높은 세포 주석이 있는 데이터 세트(예: 인간 세포 아틀라스(HCA) [@Regev2017-mw] 또는 Tabula Muris [@Quake2017])와 함께 사용하여 새 샘플의 세포 또는 클러스터를 이 참조에 투영하여 조직 구성을 고려하거나 새로운/알려지지 않은 정체성을 가진 세포를 식별할 수 있습니다. 개념적으로 이러한 투영은 새로 식별된 뉴클레오티드 또는 아미노산 서열에 대한 데이터베이스에서 가장 가까운 일치 항목을 빠르게 찾을 수 있게 해주는 인기 있는 BLAST 방법[@Altschul1990-ts]과 유사합니다. 레이블 중심 접근 방식은 또한 다른 실험실에서 수집한 유사한 생물학적 기원의 데이터 세트를 비교하여 주석 및 분석이 일관되도록 하는 데 사용할 수 있습니다.

```{r int1, echo=FALSE, out.width = '70%', fig.cap="레이블 중심 데이터 세트 비교를 사용하여 두 개의 다른 샘플의 주석을 비교할 수 있습니다."}
knitr::include_graphics("figures/CourseCompareTypes.png")
```

```{r int2, echo=FALSE, out.width = '70%',fig.cap="레이블 중심 데이터 세트 비교는 새 실험의 세포를 주석이 달린 참조에 투영할 수 있습니다."}
knitr::include_graphics("figures/CourseAtlasAssignment.png")
```

교차 데이터 세트 정규화 접근 방식은 또한 유사한 생물학적 기원의 데이터 세트를 비교하는 데 사용할 수 있으며, 레이블 중심 접근 방식과 달리 여러 데이터 세트의 공동 분석을 가능하게 하여 각 개별 데이터 세트에서 너무 희박하게 샘플링되어 안정적으로 감지되지 않을 수 있는 희귀한 세포 유형을 식별하는 것을 용이하게 합니다. 그러나 교차 데이터 세트 정규화는 각 데이터 세트의 생물학적 변동성의 상당 부분이 다른 데이터 세트와 겹친다고 가정하므로 매우 크고 다양한 참조에는 적용할 수 없습니다.


```{r int3,echo=FALSE,out.width='70%',fig.cap="교차 데이터 세트 정규화를 통해 2개 이상의 scRNASeq 데이터 세트를 공동으로 분석할 수 있습니다."}
knitr::include_graphics("figures/CourseCrossNorm.png")
```


## MNN 기반 방법

[mnnCorrect](https://www.nature.com/articles/nbt.4091)는 공동 분석을 용이하게 하기 위해 데이터 세트를 수정합니다. 두 복제 또는 두 개의 다른 실험 간의 구성 차이를 설명하기 위해 먼저 실험 전체에서 개별 세포를 일치시켜 겹치는 생물학적 구조를 찾습니다. 해당 중첩을 사용하여 어떤 발현 차원이 생물학적 상태에 해당하는지, 어떤 차원이 배치/실험 효과에 해당하는지를 학습합니다. mnnCorrect는 이러한 차원이 고차원 발현 공간에서 서로 직교한다고 가정합니다. 마지막으로 전체 발현 행렬에서 배치/실험 효과를 제거하여 수정된 행렬을 반환합니다.

데이터 세트 전체에서 개별 세포를 서로 일치시키기 위해 mnnCorrect는 라이브러리 크기 효과를 피하기 위해 코사인 거리를 사용한 다음 데이터 세트 전체에서 상호 최근접 이웃(`k`는 이웃 크기를 결정함)을 식별합니다. 겹치는 생물학적 그룹만 상호 최근접 이웃을 가져야 합니다(아래 패널 b 참조). 그러나 이는 k가 데이터 세트에서 가장 작은 생물학적 그룹의 크기와 거의 같게 설정된다고 가정하지만 너무 낮은 k는 제거하려는 배치 효과의 좋은 추정치를 얻기 위해 너무 적은 상호 최근접 이웃 쌍을 식별합니다.

생물학적/기술적 효과를 학습하는 것은 배치 보정 섹션에서 접한 RUV와 유사한 특이값 분해 또는 최적화된 irlba 패키지를 사용한 주성분 분석으로 수행되며, 이는 SVD보다 빠를 것으로 예상됩니다. `svd.dim` 매개변수는 데이터의 생물학적 구조를 요약하기 위해 유지해야 하는 차원 수를 지정하며, Metaneighbor를 사용하여 세 개의 주요 그룹을 찾았으므로 3으로 설정합니다. 이러한 추정치는 스무딩(`sigma`) 및/또는 분산 조정(`var.adj`)으로 추가 조정될 수 있습니다.


```{r int4,echo=FALSE,fig.align="center",fig.cap="상호 최근접 이웃(MNN) 통합 접근 방식의 개략도"}
knitr::include_graphics("figures/MNN.png")
```

## 정준 상관 분석(Seurat v3)

`Seurat` 패키지에는 여러 데이터 세트를 결합하기 위한 또 다른 보정 방법인 [CCA](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8?)가 포함되어 있습니다. 그러나 `mnnCorrect`와 달리 발현 행렬 자체를 직접 수정하지는 않습니다. 대신 `Seurat`는 각 데이터 세트에 대한 저차원 하위 공간을 찾은 다음 이러한 하위 공간을 수정합니다. 또한 `mnnCorrect`와 달리 `Seurat`는 한 번에 한 쌍의 데이터 세트만 결합합니다.

Seurat는 정준 상관 분석(CCA)이라는 방법을 사용하여 데이터 세트의 생물학적 구조를 식별하기 위해 유전자-유전자 상관 관계를 사용합니다. Seurat는 유전자-유전자 상관 관계에 대한 공유 구조를 학습한 다음 각 세포가 이 구조에 얼마나 잘 맞는지 평가합니다. 공유 상관 구조보다 데이터별 차원 축소 방법으로 훨씬 더 잘 설명되는 세포는 데이터 세트별 세포 유형/상태를 나타내는 것으로 간주되어 두 데이터 세트를 정렬하기 전에 폐기됩니다. 마지막으로 두 데이터 세트는 각 데이터 세트의 저차원 표현을 모집단 밀도 차이에 강건한 방식으로 정규화하는 '워핑' 알고리즘을 사용하여 정렬됩니다.

## 실제 데이터 세트의 실제 통합

최근에 발표된 여러 벤치마크가 있습니다(Chazarra-Gil et al, 2021; Tran et al, 2020; Luecken et al, 2020). 가장 자세한 간행물 중 하나(Tran 2020)는 다양한 크기와 복잡성의 여러 시뮬레이션 및 실제 데이터 세트를 사용하여 scRNA-seq 데이터 세트 통합의 [14가지 방법을 비교](https://github.com/JinmiaoChenLab/Batch-effect-removal-benchmarking)했습니다.

벤치마크에 따르면 `Harmony`, `LIGER`(최근에 `rliger`가 됨) 및 `Seurat`(v3)가 가장 좋은 성능을 보였습니다. 우리는 이 세 가지 방법의 성능을 두 가지 작업에서 설명할 것입니다. 1) 밀접하게 관련된 3' 및 5' PBMC 데이터 세트 통합, 2) 부분적으로만 겹치는 데이터 세트, 즉 전혈(적혈구 및 호중구 포함) 및 3' PBMC 데이터 세트 통합.

필요한 모든 라이브러리를 로드해 보겠습니다.

```{r int5,warning=F, message=F}
library(Seurat)
library(SeuratDisk)
library(SeuratWrappers)

library(patchwork)
library(harmony)
library(rliger)
library(reshape2)
library(RColorBrewer)
library(dplyr)
```

또한 클러스터 크기와 함께 클러스터당 다른 데이터 세트의 세포 분포를 시각화하기 위해 작성한 사용자 지정 함수를 소싱해 보겠습니다.

```{r int6}
source("utils/custom_seurat_functions.R")
```

## Seurat v3, 3' 대 5' 10k PBMC

10x Genomics 데이터 저장소에서 다운로드한 필터링된 Cell Ranger `h5` 행렬을 로드해 보겠습니다. 아래 명령을 사용하여 다운로드할 수도 있습니다.

```{r int7,eval=FALSE}
download.file("https://cf.10xgenomics.com/samples/cell-exp/4.0.0/Parent_NGSC3_DI_PBMC/Parent_NGSC3_DI_PBMC_filtered_feature_bc_matrix.h5",
              destfile = "3p_pbmc10k_filt.h5")
download.file("https://cf.10xgenomics.com/samples/cell-vdj/5.0.0/sc5p_v2_hs_PBMC_10k/sc5p_v2_hs_PBMC_10k_filtered_feature_bc_matrix.h5",
              destfile = "5p_pbmc10k_filt.h5")
```

데이터를 읽고 적절한 `Seurat` 객체를 만들어 보겠습니다. 5' 데이터 세트에는 다른 분석, 즉 VDJ 데이터가 있습니다.

```{r int8,warning=F,message=F}
matrix_3p <- Read10X_h5("data/update/3p_pbmc10k_filt.h5",use.names = T)
matrix_5p <- Read10X_h5("data/update/5p_pbmc10k_filt.h5",use.names = T)$`Gene Expression`

srat_3p   <- CreateSeuratObject(matrix_3p,project = "pbmc10k_3p")
srat_5p   <- CreateSeuratObject(matrix_5p,project = "pbmc10k_5p")
```

이제 메모리를 절약하기 위해 행렬을 제거해 보겠습니다.

```{r int9,warning=F,message=F}
rm(matrix_3p)
rm(matrix_5p)
```

미토콘드리아 유전자 및 리보솜 단백질의 분율을 계산하고 데이터 세트를 빠르고 간단하게 필터링해 보겠습니다.

```{r int10,fig.align="center"}
srat_3p[["percent.mt"]]  <- PercentageFeatureSet(srat_3p, pattern = "^MT-")
srat_3p[["percent.rbp"]] <- PercentageFeatureSet(srat_3p, pattern = "^RP[SL]")
srat_5p[["percent.mt"]]  <- PercentageFeatureSet(srat_5p, pattern = "^MT-")
srat_5p[["percent.rbp"]] <- PercentageFeatureSet(srat_5p, pattern = "^RP[SL]")

VlnPlot(srat_3p, features = c("nFeature_RNA","nCount_RNA","percent.mt","percent.rbp"), ncol = 4)
VlnPlot(srat_5p, features = c("nFeature_RNA","nCount_RNA","percent.mt","percent.rbp"), ncol = 4)
```

이제 주석이 얼마나 유사한지, 즉 유전자 이름을 비교해 보겠습니다. 동일한 것으로 나타났습니다. 둘 다 최신 `Cell Ranger` 주석인 GRCh38-2020A를 사용했습니다.

```{r int11}
table(rownames(srat_3p) %in% rownames(srat_5p)) 
```

데이터 세트를 빠르게 필터링하면 죽어가는 세포와 추정되는 이중체가 제거됩니다.

```{r int12}
srat_3p <- subset(srat_3p, subset = nFeature_RNA > 500 & nFeature_RNA < 5000 & percent.mt < 15)
srat_5p <- subset(srat_5p, subset = nFeature_RNA > 500 & nFeature_RNA < 5000 & percent.mt < 10)
```

이제 통합을 위해 `Seurat` 비네트를 따르겠습니다. 이를 위해 두 객체의 간단한 R 목록을 만들고 각각에 대해 정규화/HVG 찾기를 수행해야 합니다.

```{r int13}
pbmc_list <- list()
pbmc_list[["pbmc10k_3p"]] <- srat_3p
pbmc_list[["pbmc10k_5p"]] <- srat_5p

for (i in 1:length(pbmc_list)) {
  pbmc_list[[i]] <- NormalizeData(pbmc_list[[i]], verbose = F)
  pbmc_list[[i]] <- FindVariableFeatures(pbmc_list[[i]], selection.method = "vst", nfeatures = 2000, verbose = F)
}
```

그런 다음 다음 두 `Seurat` 명령을 사용하여 통합 앵커를 찾고 실제로 통합을 수행합니다. 약 10분이 걸립니다.

```{r int14}
pbmc_anchors    <- FindIntegrationAnchors(object.list = pbmc_list, dims = 1:30)
pbmc_seurat     <- IntegrateData(anchorset = pbmc_anchors, dims = 1:30)
```

RAM을 절약하기 위해 사용하지 않는 모든 데이터 구조를 제거해 보겠습니다.

```{r int14b}
rm(pbmc_list)
rm(pbmc_anchors)
```

Seurat 통합은 원본 데이터('RNA' `assay`)와 통합 데이터('integrated' `assay`)를 모두 포함하는 통합 객체를 만듭니다. 분석을 RNA로 설정하고 통합 전에 데이터 세트를 시각화해 보겠습니다.

```{r int15}
DefaultAssay(pbmc_seurat) <- "RNA"
```

통합되지 않은(RNA) 분석에 대해 정규화, HVG 찾기, 스케일링, PCA 및 UMAP을 수행해 보겠습니다.

```{r int16}
pbmc_seurat <- NormalizeData(pbmc_seurat, verbose = F)
pbmc_seurat <- FindVariableFeatures(pbmc_seurat, selection.method = "vst", nfeatures = 2000, verbose = F)
pbmc_seurat <- ScaleData(pbmc_seurat, verbose = F)
pbmc_seurat <- RunPCA(pbmc_seurat, npcs = 30, verbose = F)
pbmc_seurat <- RunUMAP(pbmc_seurat, reduction = "pca", dims = 1:30, verbose = F)
```

통합 전 데이터 세트의 UMAP 플롯은 명확한 분리를 보여줍니다. Seurat 플로팅 함수와 함께 `patchwork` 구문을 사용할 수 있습니다.

```{r int17,fig.align="center"}
DimPlot(pbmc_seurat,reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 10k 5' PBMC 세포, 통합 전")
```

이제 분석을 통합된 것으로 변경하고 통합된 분석에서 동일한 작업을 수행합니다(이미 정규화되었고 HVG가 선택됨).

```{r int18}
DefaultAssay(pbmc_seurat) <- "integrated"
pbmc_seurat <- ScaleData(pbmc_seurat, verbose = F)
pbmc_seurat <- RunPCA(pbmc_seurat, npcs = 30, verbose = F)
pbmc_seurat <- RunUMAP(pbmc_seurat, reduction = "pca", dims = 1:30, verbose = F)
```

마지막으로 통합된 UMAP을 플로팅해 보겠습니다.

```{r int19,fig.align="center"}
DimPlot(pbmc_seurat, reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 10k 5' PBMC 세포, 통합 후 (Seurat 3)")
```

데이터가 매우 잘 통합된 것으로 보입니다. 비교를 더 쉽게 하기 위해 분할 플롯을 시도해 보겠습니다.

```{r int20,fig.align="center"}
DimPlot(pbmc_seurat, reduction = "umap", split.by = "orig.ident") + NoLegend()
```

이제 통합된 행렬을 클러스터링하고 두 세트 간에 클러스터가 어떻게 분포되어 있는지 살펴보겠습니다.

```{r int21,fig.align="center"}
pbmc_seurat <- FindNeighbors(pbmc_seurat, dims = 1:30, k.param = 10, verbose = F)
pbmc_seurat <- FindClusters(pbmc_seurat, verbose = F)
DimPlot(pbmc_seurat,label = T) + NoLegend()
```

이제 3' 또는 5' 데이터 세트에서 온 각 클러스터의 세포 수를 계산할 수 있습니다.

```{r int22}
count_table <- table(pbmc_seurat@meta.data$seurat_clusters, pbmc_seurat@meta.data$orig.ident)
count_table
```

사용자 지정 함수를 사용하여 클러스터 간의 분포를 플로팅해 보겠습니다.

```{r int23,fig.align="center"}
plot_integrated_clusters(pbmc_seurat) 
```

```{r int23b}
rm(pbmc_seurat)
```

## Harmony, 3' 대 5' 10k PBMC

`harmony`를 사용하는 것은 다른 어떤 방법보다 훨씬 빠르며 최근 벤치마크에서 매우 잘 수행되는 것으로 나타났습니다. `Seurat`와 인터페이스하기 위한 편리한 래퍼도 있습니다. 먼저 객체를 병합해 보겠습니다(통합 없이). 일치하는 세포 바코드에 대한 메시지에 유의하십시오.

```{r int24}
pbmc_harmony    <- merge(srat_3p,srat_5p)
```

이제 이전에 했던 것과 동일한 작업을 수행해 보겠습니다.

```{r int25}
pbmc_harmony <- NormalizeData(pbmc_harmony, verbose = F)
pbmc_harmony <- FindVariableFeatures(pbmc_harmony, selection.method = "vst", nfeatures = 2000, verbose = F)
pbmc_harmony <- ScaleData(pbmc_harmony, verbose = F)
pbmc_harmony <- RunPCA(pbmc_harmony, npcs = 30, verbose = F)
pbmc_harmony <- RunUMAP(pbmc_harmony, reduction = "pca", dims = 1:30, verbose = F)
```

"이전" 플롯을 다시 플로팅해 보겠습니다.

```{r int26,fig.align="center"}
DimPlot(pbmc_harmony,reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 10k 5' PBMC 세포, 통합 전")
```

`RunHarmony`를 사용하여 `orig.ident`를 배치로 사용하여 결합된 `Seurat` 객체에서 실행합니다.

```{r int27,fig.align="center"}
pbmc_harmony <- pbmc_harmony %>% RunHarmony("orig.ident", plot_convergence = T)
```

생성된 임베딩을 확인합니다.

```{r int28}
harmony_embeddings <- Embeddings(pbmc_harmony, 'harmony')
harmony_embeddings[1:5, 1:5]
```

이후 PCA 플롯을 확인합니다.

```{r int29,fig.align="center"}
p1 <- DimPlot(object = pbmc_harmony, reduction = "harmony", pt.size = .1, group.by = "orig.ident") + NoLegend()
p2 <- VlnPlot(object = pbmc_harmony, features = "harmony_1", group.by = "orig.ident", pt.size = .1) + NoLegend()
plot_grid(p1,p2)
```

UMAP 및 클러스터링을 수행합니다.

```{r int30}
pbmc_harmony <- pbmc_harmony %>% 
  RunUMAP(reduction = "harmony", dims = 1:30, verbose = F) %>% 
  FindNeighbors(reduction = "harmony", k.param = 10, dims = 1:30) %>% 
  FindClusters() %>% 
  identity()
```

마지막으로, 위와 같이 통합된 데이터 세트의 동일한 UMAP 플롯을 수행합니다.

```{r int31,fig.align="center"}
pbmc_harmony <- SetIdent(pbmc_harmony,value = "orig.ident")
DimPlot(pbmc_harmony,reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 10k 5' PBMC 세포, 통합 후 (Harmony)")
```

```{r int32,fig.align="center"}
DimPlot(pbmc_harmony, reduction = "umap", group.by = "orig.ident", pt.size = .1, split.by = 'orig.ident') + NoLegend()
```

이것들은 `Seurat`에서 얻은 것보다 약간 나빠 보입니다.

```{r int33,fig.align="center"}
pbmc_harmony <- SetIdent(pbmc_harmony,value = "seurat_clusters")
DimPlot(pbmc_harmony,label = T) + NoLegend()
```

마지막으로 클러스터 내용을 살펴보겠습니다.

```{r int34,fig.align="center"}
plot_integrated_clusters(pbmc_harmony)
```

```{r int34b}
rm(pbmc_harmony)
```

클러스터와 그 내용은 `Seurat` 통합 후 얻은 것과 매우 유사해 보입니다. 더 자세한 분석을 위해서는 세포 유형 할당이 필요합니다.

## LIGER, 3' 대 5' 10k PBMC

다른 방법과 마찬가지로 통합 객체를 만들고 정규화/HVG/스케일링합니다. `LIGER`는 스케일링할 때 데이터를 중앙에 맞추지 않으므로 `ScaleData`의 `do.center` 옵션을 사용합니다. 마지막 두 함수는 `orig.ident`를 배치 변수로 사용하여 `rliger`를 실행하는 래퍼입니다.

```{r int35}
pbmc_liger    <- merge(srat_3p,srat_5p)

pbmc_liger    <- NormalizeData(pbmc_liger)
pbmc_liger    <- FindVariableFeatures(pbmc_liger)
pbmc_liger    <- ScaleData(pbmc_liger, split.by = "orig.ident", do.center = F)
pbmc_liger    <- RunOptimizeALS(pbmc_liger, k = 30, lambda = 5, split.by = "orig.ident") ## 이 작업은 시간이 좀 걸립니다.
pbmc_liger    <- RunQuantileNorm(pbmc_liger, split.by = "orig.ident")
```

선택적으로 `RunQuantileNorm` 후에 Louvain 클러스터링(`FindNeighbors` 및 `FindClusters`)을 수행할 수 있습니다. 이전 통합 접근 방식과 결과를 비교하기 위해 이 작업을 수행할 것입니다. 동일한 매개변수(이웃의 경우 k = 10, Louvain 클러스터링의 경우 기본 해상도)를 사용합니다.

```{r int36}
pbmc_liger    <- FindNeighbors(pbmc_liger,reduction = "iNMF",k.param = 10,dims = 1:30)
pbmc_liger    <- FindClusters(pbmc_liger)
```

이전과 마찬가지로 차원 축소 및 플로팅을 수행합니다.

```{r int37,fig.align="center"}
pbmc_liger    <- RunUMAP(pbmc_liger, dims = 1:ncol(pbmc_liger[["iNMF"]]), reduction = "iNMF", verbose = F)
pbmc_liger    <- SetIdent(pbmc_liger,value = "orig.ident")
DimPlot(pbmc_liger,reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 10k 5' PBMC 세포, 통합 후 (LIGER)")
DimPlot(pbmc_liger, reduction = "umap", group.by = "orig.ident", pt.size = .1, split.by = 'orig.ident') + NoLegend()
```

클러스터링은 `LIGER` 통합 데이터로 다소 미세해 보입니다.

```{r int38,fig.align="center"}
pbmc_liger <- SetIdent(pbmc_liger,value = "seurat_clusters")
DimPlot(pbmc_liger,reduction = "umap",label = T) + NoLegend()
```

클러스터는 매우 다르게 보이며 클러스터당 분포는 이를 확인하는 것 같습니다(두 클러스터는 각각 3' 및 5' 데이터 세트에 고유한 것으로 간주됨).

```{r int39,fig.align="center"}
plot_integrated_clusters(pbmc_liger)
```

```{r int39b}
rm(pbmc_liger)
rm(srat_3p)
rm(srat_5p)
```

## Seurat v3, 3' 10k PBMC 세포 및 전혈 STRT-Seq


이미 `/data` 폴더에 필요한 모든 파일이 있지만 GEO 데이터베이스에서 필요한 파일을 다운로드할 수 있습니다.

```{r int40,eval=FALSE}
download.file("https://ftp.ncbi.nlm.nih.gov/geo/series/GSE149nnn/GSE149938/suppl/GSE149938_umi_matrix.csv.gz",
              destfile = "GSE149938_umi_matrix.csv.gz")
download.file("https://cf.10xgenomics.com/samples/cell-exp/4.0.0/Parent_NGSC3_DI_PBMC/Parent_NGSC3_DI_PBMC_filtered_feature_bc_matrix.h5",
              destfile = "3p_pbmc10k_filt.h5")
```

```{r int41,warning=FALSE}
umi_gz <- gzfile("data/update/GSE149938_umi_matrix.csv.gz",'rt')  
umi <- read.csv(umi_gz,check.names = F,quote = "")
matrix_3p    <- Read10X_h5("data/update/3p_pbmc10k_filt.h5",use.names = T)
```

다음으로 `Seurat` 객체를 만들고 일부 메타데이터 열을 다시 정의해 보겠습니다(GEO 데이터 세트는 단순히 세포 유형을 `orig.ident` 슬롯에 넣으므로 다음에 수행하려는 작업에 방해가 됨).

```{r int42}
srat_wb <- CreateSeuratObject(t(umi),project = "whole_blood")
srat_3p <- CreateSeuratObject(matrix_3p,project = "pbmc10k_3p")
rm(umi_gz)
rm(umi)
rm(matrix_3p)
```

```{r int43}
colnames(srat_wb@meta.data)[1] <- "cell_type"
srat_wb@meta.data$orig.ident <- "whole_blood"
srat_wb@meta.data$orig.ident <- as.factor(srat_wb@meta.data$orig.ident)
head(srat_wb[[]])
```

기본 품질 관리를 수행합니다. STRT-Seq는 10x와 상당히 다르며 세포당 검출된 유전자가 훨씬 많습니다. 또한 어떤 이유에서인지 전혈 데이터 세트의 정량화된 행렬에 MT 유전자가 없습니다. 안타깝지만 치명적이지는 않습니다.

```{r int44,fig.align="center",warning=F,message=F}
srat_wb <- SetIdent(srat_wb,value = "orig.ident")

srat_wb[["percent.mt"]] <- PercentageFeatureSet(srat_wb, pattern = "^MT-")
srat_wb[["percent.rbp"]] <- PercentageFeatureSet(srat_wb, pattern = "^RP[SL]")
srat_3p[["percent.mt"]] <- PercentageFeatureSet(srat_3p, pattern = "^MT-")
srat_3p[["percent.rbp"]] <- PercentageFeatureSet(srat_3p, pattern = "^RP[SL]")

VlnPlot(srat_wb, features = c("nFeature_RNA","nCount_RNA","percent.mt","percent.rbp"), ncol = 4)
VlnPlot(srat_3p, features = c("nFeature_RNA","nCount_RNA","percent.mt","percent.rbp"), ncol = 4)
```


GEO 전혈 데이터 세트를 처리하는 데 사용된 주석은 Cell Ranger GRCh38-2020A와 상당히 다릅니다. 공통 유전자가 몇 개 있는지 살펴보겠습니다.

```{r int45}
table(rownames(srat_3p) %in% rownames(srat_wb))
common_genes <- rownames(srat_3p)[rownames(srat_3p) %in% rownames(srat_wb)]
```

유전자 수가 너무 많거나 너무 적거나 MT 유전자 함량이 너무 높은 세포를 필터링해 보겠습니다. 또한 개별 행렬을 공통 유전자로만 제한해 보겠습니다.

```{r int46}
srat_3p <- subset(srat_3p, subset = nFeature_RNA > 500 & nFeature_RNA < 5000 & percent.mt < 15)
srat_wb <- subset(srat_wb, subset = nFeature_RNA > 1000 & nFeature_RNA < 6000)

srat_3p <- srat_3p[rownames(srat_3p) %in% common_genes,]
srat_wb <- srat_wb[rownames(srat_wb) %in% common_genes,]
```

이전과 마찬가지로 `Seurat` v3의 경우 목록을 만들고 각 객체에 대해 정규화/HVG 찾기를 수행합니다.

```{r int47}
wb_list <- list()
wb_list[["pbmc10k_3p"]]   <- srat_3p
wb_list[["whole_blood"]]  <- srat_wb

for (i in 1:length(wb_list)) {
  wb_list[[i]] <- NormalizeData(wb_list[[i]], verbose = F)
  wb_list[[i]] <- FindVariableFeatures(wb_list[[i]], selection.method = "vst", nfeatures = 2000, verbose = F)
}
```

여기서 실제로 통합을 수행합니다. Seurat 3은 두 단계로 수행합니다.

```{r int48}
wb_anchors <- FindIntegrationAnchors(object.list = wb_list, dims = 1:30)
wb_seurat  <- IntegrateData(anchorset = wb_anchors, dims = 1:30)
```

```{r int48b}
rm(wb_list)
rm(wb_anchors)
```

수정되지 않은 데이터 세트의 기본 처리 및 시각화를 수행해 보겠습니다.

```{r int49,fig.align="center"}
DefaultAssay(wb_seurat) <- "RNA"
wb_seurat <- NormalizeData(wb_seurat, verbose = F)
wb_seurat <- FindVariableFeatures(wb_seurat, selection.method = "vst", nfeatures = 2000, verbose = F)
wb_seurat <- ScaleData(wb_seurat, verbose = F)
wb_seurat <- RunPCA(wb_seurat, npcs = 30, verbose = F)
wb_seurat <- RunUMAP(wb_seurat, reduction = "pca", dims = 1:30, verbose = F)

DimPlot(wb_seurat,reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 전혈, 통합 전")
```

이제 통합된 데이터 세트를 살펴보겠습니다(이미 정규화되었고 HVG가 선택됨).

```{r int50,fig.align="center"}
DefaultAssay(wb_seurat) <- "integrated"
wb_seurat <- ScaleData(wb_seurat, verbose = F)
wb_seurat <- RunPCA(wb_seurat, npcs = 30, verbose = F)
wb_seurat <- RunUMAP(wb_seurat, reduction = "pca", dims = 1:30, verbose = F)

DimPlot(wb_seurat, reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 백혈구, 통합 후 (Seurat 3)")
```


일부 마커를 살펴보겠습니다.

```{r int51,fig.align="center",warning=F,message=F}
FeaturePlot(wb_seurat,c("MS4A1","LYZ","NKG7","PPBP","LTF","HBA1","FCER1A","IL7R","FCGR3B")) & scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral")))
```

플롯에서 PBMC 데이터 세트에는 없지만 전혈 데이터 세트에는 있는 몇 가지 중요한 세포 유형이 있음을 알 수 있습니다. LTF 유전자는 호중구의 가장 두드러진 마커이며 HBA1은 적혈구에서 발현되는 헤모글로빈 유전자입니다.

이제 통합된 행렬을 클러스터링하고 두 세트 간에 클러스터가 어떻게 분포되어 있는지 살펴보겠습니다.

```{r int52,fig.align="center"}
wb_seurat <- FindNeighbors(wb_seurat, dims = 1:30, k.param = 10, verbose = F)
wb_seurat <- FindClusters(wb_seurat, verbose = F)
DimPlot(wb_seurat,label = T) + NoLegend()
```

클러스터 구성은 전혈 데이터 세트에 고유한 많은 클러스터를 보여줍니다.

```{r int53}
count_table <- table(wb_seurat@meta.data$seurat_clusters, wb_seurat@meta.data$orig.ident)
count_table
```

```{r int54,fig.align="center"}
plot_integrated_clusters(wb_seurat)
```

GSE149938에 있던 메타데이터를 활용할 수 있습니다.

```{r int55}
meta <- wb_seurat[[]]
table(meta[meta$seurat_clusters == '5',]$cell_type) ## 적혈구
table(meta[meta$seurat_clusters == '20',]$cell_type) ## 호중구
table(meta[meta$seurat_clusters == '24',]$cell_type) ## 혈장
table(meta[meta$seurat_clusters == '16',]$cell_type) ## 혈소판
```

```{r int55b}
rm(wb_seurat)
```

## Harmony, 3' 10k PBMC 세포 및 전혈 STRT-Seq

이전 접근 방식과 마찬가지로 병합된 `Seurat` 데이터 세트를 만들고 정규화하고 처리해 보겠습니다.

```{r int56}
wb_harmony    <- merge(srat_3p,srat_wb)

wb_harmony <- NormalizeData(wb_harmony, verbose = F)
wb_harmony <- FindVariableFeatures(wb_harmony, selection.method = "vst", nfeatures = 2000, verbose = F)
wb_harmony <- ScaleData(wb_harmony, verbose = F)
wb_harmony <- RunPCA(wb_harmony, npcs = 30, verbose = F)
wb_harmony <- RunUMAP(wb_harmony, reduction = "pca", dims = 1:30, verbose = F)
```


변경을 위해 PCA 플롯과 첫 번째 주성분을 따른 분포를 살펴볼 수 있습니다.

```{r int57,fig.align="center"}
p1 <- DimPlot(object = wb_harmony, reduction = "pca", pt.size = .1, group.by = "orig.ident") + NoLegend()
p2 <- VlnPlot(object = wb_harmony, features = "PC_1", group.by = "orig.ident", pt.size = .1) + NoLegend()
plot_grid(p1,p2)
```

UMAP은 또한 데이터 세트 간의 명확한 차이점을 보여줍니다.

```{r int58,fig.align="center"}
DimPlot(wb_harmony,reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 전혈, 통합 전")
```

`SeuratWrappers` 라이브러리의 `RunHarmony`라는 간단한 래퍼를 사용하여 `harmony`를 실행해 보겠습니다.

```{r int59,fig.align="center"}
wb_harmony <- wb_harmony %>% RunHarmony("orig.ident", plot_convergence = T)
```

이것은 나중에 모든 다운스트림 분석에 사용할 임베딩을 생성합니다.

```{r int60}
harmony_embeddings <- Embeddings(wb_harmony, 'harmony')
harmony_embeddings[1:5, 1:5]
```

수정된 PCA 및 분포:

```{r int61,fig.align="center"}
p1 <- DimPlot(object = wb_harmony, reduction = "harmony", pt.size = .1, group.by = "orig.ident") + NoLegend()
p2 <- VlnPlot(object = wb_harmony, features = "harmony_1", group.by = "orig.ident", pt.size = .1) + NoLegend()
plot_grid(p1,p2)
```

UMAP을 실행하고 Louvain 클러스터링을 수행합니다.

```{r int62}
wb_harmony <- wb_harmony %>% 
  RunUMAP(reduction = "harmony", dims = 1:30, verbose = F) %>% 
  FindNeighbors(reduction = "harmony", k.param = 10, dims = 1:30) %>% 
  FindClusters() %>% 
  identity()
```

```{r int63,fig.align="center"}
wb_harmony <- SetIdent(wb_harmony,value = "orig.ident")
DimPlot(wb_harmony,reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 전혈, 통합 후 (Harmony)")
DimPlot(wb_harmony, reduction = "umap", group.by = "orig.ident", pt.size = .1, split.by = 'orig.ident') + NoLegend()
```

이 데이터 세트에 대한 수정된 결과는 Seurat v3와 매우 유사해 보입니다.

```{r int64,fig.align="center"}
wb_harmony <- SetIdent(wb_harmony,value = "seurat_clusters")
DimPlot(wb_harmony,label = T) + NoLegend()
```

보다 자세한 클러스터 검사도 이를 확인하는 것 같습니다.

```{r int65,fig.align="center"}
plot_integrated_clusters(wb_harmony) 
```

```{r int65b}
rm(wb_harmony)
```

## LIGER, 3' 10k PBMC 세포 및 전혈 STRT-Seq

마지막으로 `LIGER`로 데이터 통합을 수행해 보겠습니다. 이 단계는 실행하는 데 몇 분이 걸립니다.

```{r int66}
wb_liger    <- merge(srat_3p,srat_wb)

wb_liger    <- NormalizeData(wb_liger)
wb_liger    <- FindVariableFeatures(wb_liger)
wb_liger    <- ScaleData(wb_liger, split.by = "orig.ident", do.center = F)
wb_liger    <- RunOptimizeALS(wb_liger, k = 30, lambda = 5, split.by = "orig.ident")
wb_liger    <- RunQuantileNorm(wb_liger, split.by = "orig.ident")
```

그런 다음 이전에 사용했던 것과 유사한 설정으로 Louvain 클러스터링(`FindNeighbors` 및 `FindClusters`)을 수행합니다.

```{r int67}
wb_liger    <- FindNeighbors(wb_liger,reduction = "iNMF",k.param = 10,dims = 1:30)
wb_liger    <- FindClusters(wb_liger)
```

수정된 UMAP 플롯을 몇 가지 다른 방식으로 살펴보겠습니다.

```{r int68,fig.align="center"}
wb_liger    <- RunUMAP(wb_liger, dims = 1:ncol(wb_liger[["iNMF"]]), reduction = "iNMF",verbose = F)
wb_liger <- SetIdent(wb_liger,value = "orig.ident")
DimPlot(wb_liger,reduction = "umap") + plot_annotation(title = "10k 3' PBMC 및 10k 5' PBMC 세포, 통합 후 (LIGER)")
DimPlot(wb_liger, reduction = "umap", group.by = "orig.ident", pt.size = .1, split.by = 'orig.ident') + NoLegend()
```


마지막으로 클러스터당 데이터 세트 분포를 살펴보겠습니다.

```{r int69,fig.align="center"}
plot_integrated_clusters(wb_liger)
```

```{r int69b}
rm(wb_liger)
rm(srat_wb)
rm(srat_3p)
```

### sessionInfo()

<details><summary>세션 정보 보기</summary>
```{r echo=FALSE}
sessionInfo()
```
</details>